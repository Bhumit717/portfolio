{"version":3,"sources":["../src/babel.ts","../src/common.ts","../src/filter.ts"],"sourcesContent":["import * as Babel from '@babel/standalone';\nimport type TemplateGenerator from '@babel/template';\nimport type { TraverseOptions } from '@babel/traverse';\nimport type * as babel from '@babel/types';\nimport defu from 'defu';\nimport { FORMAT_VERSION } from 'tinyest';\nimport { transpileFn } from 'tinyest-for-wgsl';\nimport {\n  type Context,\n  defaultOptions,\n  embedJSON,\n  gatherTgpuAliases,\n  getFunctionName,\n  isShellImplementationCall,\n  type Options,\n  performExpressionNaming,\n  useGpuDirective,\n} from './common.ts';\nimport { createFilterForId } from './filter.ts';\n\n// NOTE: @babel/standalone does expose internal packages, as specified in the docs, but the\n// typing for @babel/standalone does not expose them.\nconst template = (\n  Babel as unknown as { packages: { template: typeof TemplateGenerator } }\n).packages.template;\nconst types = (Babel as unknown as { packages: { types: typeof babel } })\n  .packages.types;\n\nfunction containsUseGpuDirective(\n  node:\n    | babel.FunctionDeclaration\n    | babel.FunctionExpression\n    | babel.ArrowFunctionExpression,\n): boolean {\n  return ((\n    'directives' in node.body ? (node.body?.directives ?? []) : []\n  )\n    .map((directive) => directive.value.value))\n    .includes(useGpuDirective);\n}\n\nfunction i(identifier: string): babel.Identifier {\n  return types.identifier(identifier);\n}\n\nfunction functionToTranspiled(\n  node: babel.ArrowFunctionExpression | babel.FunctionExpression,\n  parent: babel.Node | null,\n): babel.CallExpression {\n  const { params, body, externalNames } = transpileFn(node);\n  const maybeName = getFunctionName(node, parent);\n\n  const metadata = types.objectExpression([\n    types.objectProperty(\n      i('v'),\n      types.numericLiteral(FORMAT_VERSION),\n    ),\n    types.objectProperty(\n      i('name'),\n      maybeName ? types.stringLiteral(maybeName) : types.buildUndefinedNode(),\n    ),\n    types.objectProperty(\n      i('ast'),\n      template.expression`${embedJSON({ params, body, externalNames })}`(),\n    ),\n    types.objectProperty(\n      i('externals'),\n      types.arrowFunctionExpression(\n        [],\n        types.blockStatement([\n          types.returnStatement(\n            types.objectExpression(\n              externalNames.map((name) =>\n                types.objectProperty(\n                  i(name),\n                  i(name),\n                  false,\n                  /* shorthand */ name !== 'this',\n                )\n              ),\n            ),\n          ),\n        ]),\n      ),\n    ),\n  ]);\n\n  return types.callExpression(\n    types.arrowFunctionExpression(\n      [i('$')],\n      types.logicalExpression(\n        '&&',\n        types.callExpression(\n          types.memberExpression(\n            types.assignmentExpression(\n              '??=',\n              types.memberExpression(i('globalThis'), i('__TYPEGPU_META__')),\n              types.newExpression(i('WeakMap'), []),\n            ),\n            i('set'),\n          ),\n          [\n            types.assignmentExpression(\n              '=',\n              types.memberExpression(i('$'), i('f')),\n              node,\n            ),\n            metadata,\n          ],\n        ),\n        types.memberExpression(i('$'), i('f')),\n      ),\n    ),\n    [types.objectExpression([])],\n  );\n}\n\nfunction wrapInAutoName(\n  node: babel.Expression,\n  name: string,\n) {\n  return types.callExpression(\n    template.expression('globalThis.__TYPEGPU_AUTONAME__ ?? (a => a)', {\n      placeholderPattern: false,\n    })(),\n    [node, types.stringLiteral(name)],\n  );\n}\n\nfunction functionVisitor(ctx: Context): TraverseOptions {\n  return {\n    VariableDeclarator(path) {\n      performExpressionNaming(ctx, path.node, (node, name) => {\n        path.get('init').replaceWith(wrapInAutoName(node, name));\n      });\n    },\n\n    AssignmentExpression(path) {\n      performExpressionNaming(ctx, path.node, (node, name) => {\n        path.get('right').replaceWith(wrapInAutoName(node, name));\n      });\n    },\n\n    ObjectProperty(path) {\n      performExpressionNaming(ctx, path.node, (node, name) => {\n        path.get('value').replaceWith(wrapInAutoName(node, name));\n      });\n    },\n\n    ClassProperty(path) {\n      performExpressionNaming(ctx, path.node, (node, name) => {\n        path.get('value').replaceWith(wrapInAutoName(node, name));\n      });\n    },\n\n    ImportDeclaration(path) {\n      gatherTgpuAliases(path.node, ctx);\n    },\n\n    ArrowFunctionExpression(path) {\n      const node = path.node;\n      const parent = path.parentPath.node;\n      if (containsUseGpuDirective(node)) {\n        path.replaceWith(functionToTranspiled(node, parent));\n        path.skip();\n      }\n    },\n\n    FunctionExpression(path) {\n      const node = path.node;\n      const parent = path.parentPath.node;\n      if (containsUseGpuDirective(node)) {\n        path.replaceWith(functionToTranspiled(node, parent));\n        path.skip();\n      }\n    },\n\n    FunctionDeclaration(path) {\n      const node = path.node;\n      const parent = path.parentPath.node;\n      const expression = types.functionExpression(\n        node.id,\n        node.params,\n        node.body,\n      );\n\n      if (containsUseGpuDirective(path.node) && node.id) {\n        path.replaceWith(\n          types.variableDeclaration('const', [\n            types.variableDeclarator(\n              node.id,\n              functionToTranspiled(expression, parent),\n            ),\n          ]),\n        );\n        path.skip();\n      }\n    },\n\n    CallExpression(path) {\n      const node = path.node;\n\n      if (isShellImplementationCall(node, ctx)) {\n        const implementation = node.arguments[0];\n\n        if (\n          implementation &&\n          (implementation.type === 'FunctionExpression' ||\n            implementation.type === 'ArrowFunctionExpression')\n        ) {\n          const transpiled = functionToTranspiled(\n            implementation,\n            null,\n          ) as babel.CallExpression;\n\n          path.replaceWith(\n            types.callExpression(node.callee, [\n              transpiled,\n            ]),\n          );\n\n          path.skip();\n        }\n      }\n    },\n  };\n}\n\nexport default function () {\n  return {\n    visitor: {\n      Program(path, state) {\n        // biome-ignore lint/suspicious/noExplicitAny: <oh babel babel...>\n        const options = defu((state as any).opts as Options, defaultOptions);\n        // biome-ignore lint/suspicious/noExplicitAny: <oh babel babel...>\n        const id: string | undefined = (state as any).filename;\n\n        const filter = createFilterForId(options);\n        if (id && filter && !filter?.(id)) {\n          return;\n        }\n\n        const ctx: Context = {\n          tgpuAliases: new Set<string>(\n            options.forceTgpuAlias ? [options.forceTgpuAlias] : [],\n          ),\n          fileId: id,\n          autoNamingEnabled: options.autoNamingEnabled,\n        };\n\n        path.traverse(functionVisitor(ctx));\n      },\n    } satisfies TraverseOptions,\n  };\n}\n","import type * as babel from '@babel/types';\nimport type * as acorn from 'acorn';\nimport type { FilterPattern } from 'unplugin';\n\nexport type Context = {\n  /**\n   * How the `tgpu` object is used in code. Since it can be aliased, we\n   * need to catch that and act accordingly.\n   */\n  tgpuAliases: Set<string>;\n  fileId?: string | undefined;\n  autoNamingEnabled: boolean;\n};\n\nexport interface Options {\n  /** @default [/\\.m?[jt]sx?$/] */\n  include?: FilterPattern;\n\n  /** @default undefined */\n  exclude?: FilterPattern;\n\n  /** @default undefined */\n  enforce?: 'post' | 'pre' | undefined;\n\n  /** @default undefined */\n  forceTgpuAlias?: string | undefined;\n\n  /** @default true */\n  autoNamingEnabled?: boolean | undefined;\n\n  /**\n   * Skipping files that don't contain \"typegpu\", \"tgpu\" or \"use gpu\".\n   * In case this early pruning hinders transformation, you\n   * can disable it.\n   *\n   * @default true\n   */\n  earlyPruning?: boolean | undefined;\n}\n\nexport const defaultOptions = {\n  include: /\\.m?[jt]sx?(?:\\?.*)?$/,\n  autoNamingEnabled: true,\n  earlyPruning: true,\n};\n\nexport function embedJSON(jsValue: unknown) {\n  return JSON.stringify(jsValue)\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029');\n}\n\n/**\n * Checks if `node` is an alias for the 'tgpu' object, traditionally\n * available via `import tgpu from 'typegpu'`.\n */\nfunction isTgpu(ctx: Context, node: babel.Node | acorn.AnyNode): boolean {\n  let path = '';\n\n  let tail = node;\n  while (true) {\n    if (tail.type === 'MemberExpression') {\n      if (\n        (tail.property.type === 'Literal' ||\n          tail.property.type === 'StringLiteral') &&\n        tail.property.value === '~unstable'\n      ) {\n        // Bypassing the '~unstable' property.\n        tail = tail.object;\n        continue;\n      }\n\n      if (tail.property.type !== 'Identifier') {\n        // Not handling computed expressions.\n        break;\n      }\n\n      path = path ? `${tail.property.name}.${path}` : tail.property.name;\n      tail = tail.object;\n    } else if (tail.type === 'Identifier') {\n      path = path ? `${tail.name}.${path}` : tail.name;\n      break;\n    } else {\n      break;\n    }\n  }\n\n  return ctx.tgpuAliases.has(path);\n}\n\nexport function gatherTgpuAliases(\n  node: acorn.ImportDeclaration | babel.ImportDeclaration,\n  ctx: Context,\n) {\n  if (node.source.value === 'typegpu') {\n    for (const spec of node.specifiers) {\n      if (\n        // The default export of 'typegpu' is the `tgpu` object.\n        spec.type === 'ImportDefaultSpecifier' ||\n        // Aliasing 'tgpu' while importing, e.g. import { tgpu as t } from 'typegpu';\n        (spec.type === 'ImportSpecifier' &&\n          spec.imported.type === 'Identifier' &&\n          spec.imported.name === 'tgpu')\n      ) {\n        ctx.tgpuAliases.add(spec.local.name);\n      } else if (spec.type === 'ImportNamespaceSpecifier') {\n        // Importing everything, e.g. import * as t from 'typegpu';\n        ctx.tgpuAliases.add(`${spec.local.name}.tgpu`);\n      }\n    }\n  }\n}\n\nconst fnShellFunctionNames = ['fn', 'vertexFn', 'fragmentFn', 'computeFn'];\n\nexport function isShellImplementationCall(\n  node: acorn.CallExpression | babel.CallExpression,\n  ctx: Context,\n) {\n  return (\n    node.callee.type === 'CallExpression' &&\n    node.callee.callee.type === 'MemberExpression' &&\n    node.callee.callee.property.type === 'Identifier' &&\n    fnShellFunctionNames.includes(node.callee.callee.property.name) &&\n    node.arguments.length === 1 && isTgpu(ctx, node.callee.callee.object)\n  );\n}\n\nexport function getFunctionName(\n  node: acorn.AnyNode | babel.Node,\n  parent: acorn.AnyNode | babel.Node | null,\n): string | undefined {\n  if (\n    parent?.type === 'VariableDeclarator' && parent.id.type === 'Identifier'\n  ) {\n    return parent.id.name;\n  }\n  return node.type === 'FunctionDeclaration' ||\n      node.type === 'FunctionExpression'\n    ? node.id?.name\n    : undefined;\n}\n\nconst resourceConstructors: string[] = [\n  // tgpu\n  'bindGroupLayout',\n  'vertexLayout',\n  'privateVar',\n  'workgroupVar',\n  'const',\n  // tgpu['~unstable']\n  'slot',\n  'accessor',\n  'comptime',\n  ...fnShellFunctionNames,\n  // d\n  'struct',\n  'unstruct',\n  // root\n  'createBuffer',\n  'createMutable',\n  'createReadonly',\n  'createUniform',\n  'createQuerySet',\n  // root['~unstable']\n  'createPipeline',\n  'createGuardedComputePipeline',\n  'createTexture',\n  'createSampler',\n  'createComparisonSampler',\n];\n\n/**\n * Checks if `node` should be wrapped in an autoname function.\n * Since it is mostly for debugging and clean WGSL generation,\n * some false positives and false negatives are admissible.\n */\nfunction containsResourceConstructorCall(\n  node: acorn.AnyNode | babel.Node,\n  ctx: Context,\n) {\n  if (node.type === 'CallExpression') {\n    if (isShellImplementationCall(node, ctx)) {\n      return true;\n    }\n    // struct({...})\n    if (\n      node.callee.type === 'Identifier' &&\n      resourceConstructors.includes(node.callee.name)\n    ) {\n      return true;\n    }\n    if (node.callee.type === 'MemberExpression') {\n      if (node.callee.property.type === 'Identifier') {\n        // root.createBuffer({...})\n        if (resourceConstructors.includes(node.callee.property.name)) {\n          return true;\n        }\n        if (node.callee.property.name === '$name') {\n          return false;\n        }\n      }\n      // root.createBuffer(d.f32).$usage('storage')\n      return containsResourceConstructorCall(node.callee.object, ctx);\n    }\n  }\n  if (node.type === 'TaggedTemplateExpression') {\n    return containsResourceConstructorCall(node.tag, ctx);\n  }\n  return false;\n}\n\n/**\n * Tries to find an identifier in a node.\n *\n * @example\n * // syntax is simplified, imagine the arguments are appropriate nodes instead\n * tryFindIdentifier('myBuffer'); // 'myBuffer'\n * tryFindIdentifier('buffers.myBuffer'); // 'myBuffer'\n * tryFindIdentifier('this.myBuffer'); // 'myBuffer'\n * tryFindIdentifier('[a, b]'); // undefined\n */\nfunction tryFindIdentifier(\n  node: acorn.AnyNode | babel.Node,\n): string | undefined {\n  if (node.type === 'Identifier') {\n    return node.name;\n  }\n  if (node.type === 'MemberExpression') {\n    return tryFindIdentifier(node.property);\n  }\n}\n\ntype ExpressionFor<T extends acorn.AnyNode | babel.Node> = T extends\n  acorn.AnyNode ? acorn.Expression : babel.Expression;\n\n/**\n * Checks if `node` contains a label and a tgpu expression that could be named.\n * If so, it calls the provided callback. Nodes selected for naming include:\n *\n * `let name = tgpu.bindGroupLayout({});` (VariableDeclarator)\n *\n * `name = tgpu.bindGroupLayout({});` (AssignmentExpression)\n *\n * `property: tgpu.bindGroupLayout({})` (Property/ObjectProperty)\n *\n * Since it is mostly for debugging and clean WGSL generation,\n * some false positives and false negatives are admissible.\n *\n * This function is NOT used for auto-naming shell-less functions.\n * Those are handled separately.\n *\n * @privateRemarks\n * When adding new checks, you need to call this method in the corresponding node in Babel.\n */\nexport function performExpressionNaming<T extends acorn.AnyNode | babel.Node>(\n  ctx: Context,\n  node: T,\n  namingCallback: (node: ExpressionFor<T>, name: string) => void,\n) {\n  if (!ctx.autoNamingEnabled) {\n    return;\n  }\n\n  if (\n    node.type === 'VariableDeclarator' &&\n    node.id.type === 'Identifier' &&\n    node.init &&\n    containsResourceConstructorCall(node.init, ctx)\n  ) {\n    namingCallback(node.init as ExpressionFor<T>, node.id.name);\n  } else if (\n    node.type === 'AssignmentExpression' &&\n    containsResourceConstructorCall(node.right, ctx)\n  ) {\n    const maybeName = tryFindIdentifier(node.left);\n    if (maybeName) {\n      namingCallback(node.right as ExpressionFor<T>, maybeName);\n    }\n  } else if (\n    (node.type === 'Property' || node.type === 'ObjectProperty') &&\n    node.key.type === 'Identifier' &&\n    containsResourceConstructorCall(node.value, ctx)\n  ) {\n    namingCallback(node.value as ExpressionFor<T>, node.key.name);\n  } else if (\n    (node.type === 'ClassProperty' || node.type === 'PropertyDefinition') &&\n    node.value &&\n    node.key.type === 'Identifier' &&\n    containsResourceConstructorCall(node.value, ctx)\n  ) {\n    namingCallback(node.value as ExpressionFor<T>, node.key.name);\n  }\n}\n\nexport const useGpuDirective = 'use gpu';\n\n/** Regular expressions used for early pruning (to avoid unnecessary parsing, which is expensive) */\nexport const earlyPruneRegex = [/[\"']use gpu[\"']/, /t(ype)?gpu/];\n","// Copied from https://github.com/unjs/unplugin/blob/f514bf8e2d751b48b3a5acb1077eb1292d9711b3/src/utils/filter.ts#L2\n// Used only in the babel version of the plugin, since others can rely on native unplugin functionality.\n\nimport { resolve } from 'pathe';\nimport picomatch from 'picomatch';\nimport type {\n  Arrayable,\n  Nullable,\n  StringFilter,\n  StringOrRegExp,\n} from 'unplugin';\n\nfunction toArray<T>(array?: Nullable<Arrayable<T>>): Array<T> {\n  const result = array || [];\n  if (Array.isArray(result)) return result;\n  return [result];\n}\n\nconst BACKSLASH_REGEX = /\\\\/g;\nfunction normalize(path: string): string {\n  return path.replace(BACKSLASH_REGEX, '/');\n}\n\nconst ABSOLUTE_PATH_REGEX = /^(?:\\/|(?:[A-Z]:)?[/\\\\|])/i;\nfunction isAbsolute(path: string): boolean {\n  return ABSOLUTE_PATH_REGEX.test(path);\n}\n\nexport type PluginFilter = (input: string) => boolean;\nexport type TransformHookFilter = (id: string, code: string) => boolean;\n\ninterface NormalizedStringFilter {\n  include?: StringOrRegExp[] | undefined;\n  exclude?: StringOrRegExp[] | undefined;\n}\n\nfunction getMatcherString(glob: string, cwd: string) {\n  if (glob.startsWith('**') || isAbsolute(glob)) {\n    return normalize(glob);\n  }\n\n  const resolved = resolve(cwd, glob);\n  return normalize(resolved);\n}\n\nfunction patternToIdFilter(pattern: StringOrRegExp): PluginFilter {\n  if (pattern instanceof RegExp) {\n    return (id: string) => {\n      const normalizedId = normalize(id);\n      const result = pattern.test(normalizedId);\n      pattern.lastIndex = 0;\n      return result;\n    };\n  }\n  const cwd = process.cwd();\n  const glob = getMatcherString(pattern, cwd);\n  const matcher = picomatch(glob, { dot: true });\n  return (id: string) => {\n    const normalizedId = normalize(id);\n    return matcher(normalizedId);\n  };\n}\n\nfunction patternToCodeFilter(pattern: StringOrRegExp): PluginFilter {\n  if (pattern instanceof RegExp) {\n    return (code: string) => {\n      const result = pattern.test(code);\n      pattern.lastIndex = 0;\n      return result;\n    };\n  }\n  return (code: string) => code.includes(pattern);\n}\n\nfunction createFilter(\n  exclude: PluginFilter[] | undefined,\n  include: PluginFilter[] | undefined,\n): PluginFilter | undefined {\n  if (!exclude && !include) {\n    return;\n  }\n\n  return (input) => {\n    if (exclude?.some((filter) => filter(input))) {\n      return false;\n    }\n    if (include?.some((filter) => filter(input))) {\n      return true;\n    }\n    return !(include && include.length > 0);\n  };\n}\n\nfunction normalizeFilter(filter: StringFilter): NormalizedStringFilter {\n  if (typeof filter === 'string' || filter instanceof RegExp) {\n    return {\n      include: [filter],\n    };\n  }\n  if (Array.isArray(filter)) {\n    return {\n      include: filter,\n    };\n  }\n  return {\n    exclude: filter.exclude ? toArray(filter.exclude) : undefined,\n    include: filter.include ? toArray(filter.include) : undefined,\n  };\n}\n\nfunction createIdFilter(\n  filter: StringFilter | undefined,\n): PluginFilter | undefined {\n  if (!filter) return;\n  const { exclude, include } = normalizeFilter(filter);\n  const excludeFilter = exclude?.map(patternToIdFilter);\n  const includeFilter = include?.map(patternToIdFilter);\n  return createFilter(excludeFilter, includeFilter);\n}\n\nfunction createCodeFilter(\n  filter: StringFilter | undefined,\n): PluginFilter | undefined {\n  if (!filter) return;\n  const { exclude, include } = normalizeFilter(filter);\n  const excludeFilter = exclude?.map(patternToCodeFilter);\n  const includeFilter = include?.map(patternToCodeFilter);\n  return createFilter(excludeFilter, includeFilter);\n}\n\nexport function createFilterForId(\n  filter: StringFilter | undefined,\n): PluginFilter | undefined {\n  const filterFunction = createIdFilter(filter);\n  return filterFunction ? (id) => !!filterFunction(id) : undefined;\n}\n\nfunction createFilterForTransform(\n  idFilter: StringFilter | undefined,\n  codeFilter: StringFilter | undefined,\n): TransformHookFilter | undefined {\n  if (!idFilter && !codeFilter) return;\n  const idFilterFunction = createIdFilter(idFilter);\n  const codeFilterFunction = createCodeFilter(codeFilter);\n  return (id, code) => {\n    let fallback = true;\n    if (idFilterFunction) {\n      fallback &&= idFilterFunction(id);\n    }\n    if (!fallback) {\n      return false;\n    }\n\n    if (codeFilterFunction) {\n      fallback &&= codeFilterFunction(code);\n    }\n    return fallback;\n  };\n}\n"],"mappings":"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","names":["Babel","defu","FORMAT_VERSION","transpileFn","defaultOptions","embedJSON","jsValue","isTgpu","ctx","node","path","tail","gatherTgpuAliases","spec","fnShellFunctionNames","isShellImplementationCall","getFunctionName","parent","_a","resourceConstructors","containsResourceConstructorCall","tryFindIdentifier","performExpressionNaming","namingCallback","maybeName","useGpuDirective","earlyPruneRegex","resolve","picomatch","toArray","array","result","BACKSLASH_REGEX","normalize","path","ABSOLUTE_PATH_REGEX","isAbsolute","getMatcherString","glob","cwd","resolved","patternToIdFilter","pattern","id","normalizedId","matcher","createFilter","exclude","include","input","filter","normalizeFilter","toArray","createIdFilter","excludeFilter","patternToIdFilter","includeFilter","createFilterForId","filter","filterFunction","createIdFilter","id","template","types","containsUseGpuDirective","node","_a","_b","directive","useGpuDirective","i","identifier","functionToTranspiled","parent","params","body","externalNames","transpileFn","maybeName","getFunctionName","metadata","FORMAT_VERSION","embedJSON","name","wrapInAutoName","functionVisitor","ctx","path","performExpressionNaming","gatherTgpuAliases","expression","isShellImplementationCall","implementation","transpiled","babel_default","state","options","defu","defaultOptions","id","filter","createFilterForId"]}