{"version":3,"sources":["../src/babel.ts","../src/common.ts"],"names":["defaultOptions","embedJSON","jsValue","isTgpu","ctx","node","path","tail"],"mappings":"AAAA,whBAAuB,wEAIN,kCACc,kDACH,ICkCfA,CAAAA,CAAiB,CAC5B,OAAA,CAAS,uBAAA,CACT,iBAAA,CAAmB,CAAA,CAAA,CACnB,YAAA,CAAc,CAAA,CAChB,CAAA,CAEO,SAASC,CAAAA,CAAUC,CAAAA,CAAkB,CAC1C,OAAO,IAAA,CAAK,SAAA,CAAUA,CAAO,CAAA,CAC1B,OAAA,CAAQ,SAAA,CAAW,SAAS,CAAA,CAC5B,OAAA,CAAQ,SAAA,CAAW,SAAS,CACjC,CAMA,SAASC,CAAAA,CAAOC,CAAAA,CAAcC,CAAAA,CAA2C,CACvE,IAAIC,CAAAA,CAAO,EAAA,CAEPC,CAAAA,CAAOF,CAAAA,CACX,GAAA,CAAA,CAAA,CAAA,CACE,EAAA,CAAIE,CAAAA,CAAK,IAAA,GAAS,kBAAA,CAAoB,CACpC,EAAA,CAAA,CACGA,CAAAA,CAAK,QAAA,CAAS,IAAA,GAAS,SAAA,EACtBA,CAAAA,CAAK,QAAA,CAAS,IAAA,GAAS,eAAA,CAAA,EACzBA,CAAAA,CAAK,QAAA,CAAS,KAAA,GAAU,WAAA,CACxB,CAEAA,CAAAA,CAAOA,CAAAA,CAAK,MAAA,CACZ,QACF,CAEA,EAAA,CAAIA,CAAAA,CAAK,QAAA,CAAS,IAAA,GAAS,YAAA,CAEzB,KAAA,CAGFD,CAAAA,CAAOA,CAAAA,CAAO,CAAA,EAAA","file":"/Users/iwo/Projects/wigsill/packages/unplugin-typegpu/dist/chunk-DEVVEJF4.cjs","sourcesContent":["import * as Babel from '@babel/standalone';\nimport type TemplateGenerator from '@babel/template';\nimport type { TraverseOptions } from '@babel/traverse';\nimport type * as babel from '@babel/types';\nimport defu from 'defu';\nimport { FORMAT_VERSION } from 'tinyest';\nimport { transpileFn } from 'tinyest-for-wgsl';\nimport {\n  type Context,\n  defaultOptions,\n  embedJSON,\n  gatherTgpuAliases,\n  getFunctionName,\n  isShellImplementationCall,\n  type Options,\n  performExpressionNaming,\n  useGpuDirective,\n} from './common.ts';\nimport { createFilterForId } from './filter.ts';\n\n// NOTE: @babel/standalone does expose internal packages, as specified in the docs, but the\n// typing for @babel/standalone does not expose them.\nconst template = (\n  Babel as unknown as { packages: { template: typeof TemplateGenerator } }\n).packages.template;\nconst types = (Babel as unknown as { packages: { types: typeof babel } })\n  .packages.types;\n\nfunction containsUseGpuDirective(\n  node:\n    | babel.FunctionDeclaration\n    | babel.FunctionExpression\n    | babel.ArrowFunctionExpression,\n): boolean {\n  return ((\n    'directives' in node.body ? (node.body?.directives ?? []) : []\n  )\n    .map((directive) => directive.value.value))\n    .includes(useGpuDirective);\n}\n\nfunction i(identifier: string): babel.Identifier {\n  return types.identifier(identifier);\n}\n\nfunction functionToTranspiled(\n  node: babel.ArrowFunctionExpression | babel.FunctionExpression,\n  parent: babel.Node | null,\n): babel.CallExpression {\n  const { params, body, externalNames } = transpileFn(node);\n  const maybeName = getFunctionName(node, parent);\n\n  const metadata = types.objectExpression([\n    types.objectProperty(\n      i('v'),\n      types.numericLiteral(FORMAT_VERSION),\n    ),\n    types.objectProperty(\n      i('name'),\n      maybeName ? types.stringLiteral(maybeName) : types.buildUndefinedNode(),\n    ),\n    types.objectProperty(\n      i('ast'),\n      template.expression`${embedJSON({ params, body, externalNames })}`(),\n    ),\n    types.objectProperty(\n      i('externals'),\n      types.arrowFunctionExpression(\n        [],\n        types.blockStatement([\n          types.returnStatement(\n            types.objectExpression(\n              externalNames.map((name) =>\n                types.objectProperty(\n                  i(name),\n                  i(name),\n                  false,\n                  /* shorthand */ name !== 'this',\n                )\n              ),\n            ),\n          ),\n        ]),\n      ),\n    ),\n  ]);\n\n  return types.callExpression(\n    types.arrowFunctionExpression(\n      [i('$')],\n      types.logicalExpression(\n        '&&',\n        types.callExpression(\n          types.memberExpression(\n            types.assignmentExpression(\n              '??=',\n              types.memberExpression(i('globalThis'), i('__TYPEGPU_META__')),\n              types.newExpression(i('WeakMap'), []),\n            ),\n            i('set'),\n          ),\n          [\n            types.assignmentExpression(\n              '=',\n              types.memberExpression(i('$'), i('f')),\n              node,\n            ),\n            metadata,\n          ],\n        ),\n        types.memberExpression(i('$'), i('f')),\n      ),\n    ),\n    [types.objectExpression([])],\n  );\n}\n\nfunction wrapInAutoName(\n  node: babel.Expression,\n  name: string,\n) {\n  return types.callExpression(\n    template.expression('globalThis.__TYPEGPU_AUTONAME__ ?? (a => a)', {\n      placeholderPattern: false,\n    })(),\n    [node, types.stringLiteral(name)],\n  );\n}\n\nfunction functionVisitor(ctx: Context): TraverseOptions {\n  return {\n    VariableDeclarator(path) {\n      performExpressionNaming(ctx, path.node, (node, name) => {\n        path.get('init').replaceWith(wrapInAutoName(node, name));\n      });\n    },\n\n    AssignmentExpression(path) {\n      performExpressionNaming(ctx, path.node, (node, name) => {\n        path.get('right').replaceWith(wrapInAutoName(node, name));\n      });\n    },\n\n    ObjectProperty(path) {\n      performExpressionNaming(ctx, path.node, (node, name) => {\n        path.get('value').replaceWith(wrapInAutoName(node, name));\n      });\n    },\n\n    ClassProperty(path) {\n      performExpressionNaming(ctx, path.node, (node, name) => {\n        path.get('value').replaceWith(wrapInAutoName(node, name));\n      });\n    },\n\n    ImportDeclaration(path) {\n      gatherTgpuAliases(path.node, ctx);\n    },\n\n    ArrowFunctionExpression(path) {\n      const node = path.node;\n      const parent = path.parentPath.node;\n      if (containsUseGpuDirective(node)) {\n        path.replaceWith(functionToTranspiled(node, parent));\n        path.skip();\n      }\n    },\n\n    FunctionExpression(path) {\n      const node = path.node;\n      const parent = path.parentPath.node;\n      if (containsUseGpuDirective(node)) {\n        path.replaceWith(functionToTranspiled(node, parent));\n        path.skip();\n      }\n    },\n\n    FunctionDeclaration(path) {\n      const node = path.node;\n      const parent = path.parentPath.node;\n      const expression = types.functionExpression(\n        node.id,\n        node.params,\n        node.body,\n      );\n\n      if (containsUseGpuDirective(path.node) && node.id) {\n        path.replaceWith(\n          types.variableDeclaration('const', [\n            types.variableDeclarator(\n              node.id,\n              functionToTranspiled(expression, parent),\n            ),\n          ]),\n        );\n        path.skip();\n      }\n    },\n\n    CallExpression(path) {\n      const node = path.node;\n\n      if (isShellImplementationCall(node, ctx)) {\n        const implementation = node.arguments[0];\n\n        if (\n          implementation &&\n          (implementation.type === 'FunctionExpression' ||\n            implementation.type === 'ArrowFunctionExpression')\n        ) {\n          const transpiled = functionToTranspiled(\n            implementation,\n            null,\n          ) as babel.CallExpression;\n\n          path.replaceWith(\n            types.callExpression(node.callee, [\n              transpiled,\n            ]),\n          );\n\n          path.skip();\n        }\n      }\n    },\n  };\n}\n\nexport default function () {\n  return {\n    visitor: {\n      Program(path, state) {\n        // biome-ignore lint/suspicious/noExplicitAny: <oh babel babel...>\n        const options = defu((state as any).opts as Options, defaultOptions);\n        // biome-ignore lint/suspicious/noExplicitAny: <oh babel babel...>\n        const id: string | undefined = (state as any).filename;\n\n        const filter = createFilterForId(options);\n        if (id && filter && !filter?.(id)) {\n          return;\n        }\n\n        const ctx: Context = {\n          tgpuAliases: new Set<string>(\n            options.forceTgpuAlias ? [options.forceTgpuAlias] : [],\n          ),\n          fileId: id,\n          autoNamingEnabled: options.autoNamingEnabled,\n        };\n\n        path.traverse(functionVisitor(ctx));\n      },\n    } satisfies TraverseOptions,\n  };\n}\n","import type * as babel from '@babel/types';\nimport type * as acorn from 'acorn';\nimport type { FilterPattern } from 'unplugin';\n\nexport type Context = {\n  /**\n   * How the `tgpu` object is used in code. Since it can be aliased, we\n   * need to catch that and act accordingly.\n   */\n  tgpuAliases: Set<string>;\n  fileId?: string | undefined;\n  autoNamingEnabled: boolean;\n};\n\nexport interface Options {\n  /** @default [/\\.m?[jt]sx?$/] */\n  include?: FilterPattern;\n\n  /** @default undefined */\n  exclude?: FilterPattern;\n\n  /** @default undefined */\n  enforce?: 'post' | 'pre' | undefined;\n\n  /** @default undefined */\n  forceTgpuAlias?: string | undefined;\n\n  /** @default true */\n  autoNamingEnabled?: boolean | undefined;\n\n  /**\n   * Skipping files that don't contain \"typegpu\", \"tgpu\" or \"use gpu\".\n   * In case this early pruning hinders transformation, you\n   * can disable it.\n   *\n   * @default true\n   */\n  earlyPruning?: boolean | undefined;\n}\n\nexport const defaultOptions = {\n  include: /\\.m?[jt]sx?(?:\\?.*)?$/,\n  autoNamingEnabled: true,\n  earlyPruning: true,\n};\n\nexport function embedJSON(jsValue: unknown) {\n  return JSON.stringify(jsValue)\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029');\n}\n\n/**\n * Checks if `node` is an alias for the 'tgpu' object, traditionally\n * available via `import tgpu from 'typegpu'`.\n */\nfunction isTgpu(ctx: Context, node: babel.Node | acorn.AnyNode): boolean {\n  let path = '';\n\n  let tail = node;\n  while (true) {\n    if (tail.type === 'MemberExpression') {\n      if (\n        (tail.property.type === 'Literal' ||\n          tail.property.type === 'StringLiteral') &&\n        tail.property.value === '~unstable'\n      ) {\n        // Bypassing the '~unstable' property.\n        tail = tail.object;\n        continue;\n      }\n\n      if (tail.property.type !== 'Identifier') {\n        // Not handling computed expressions.\n        break;\n      }\n\n      path = path ? `${tail.property.name}.${path}` : tail.property.name;\n      tail = tail.object;\n    } else if (tail.type === 'Identifier') {\n      path = path ? `${tail.name}.${path}` : tail.name;\n      break;\n    } else {\n      break;\n    }\n  }\n\n  return ctx.tgpuAliases.has(path);\n}\n\nexport function gatherTgpuAliases(\n  node: acorn.ImportDeclaration | babel.ImportDeclaration,\n  ctx: Context,\n) {\n  if (node.source.value === 'typegpu') {\n    for (const spec of node.specifiers) {\n      if (\n        // The default export of 'typegpu' is the `tgpu` object.\n        spec.type === 'ImportDefaultSpecifier' ||\n        // Aliasing 'tgpu' while importing, e.g. import { tgpu as t } from 'typegpu';\n        (spec.type === 'ImportSpecifier' &&\n          spec.imported.type === 'Identifier' &&\n          spec.imported.name === 'tgpu')\n      ) {\n        ctx.tgpuAliases.add(spec.local.name);\n      } else if (spec.type === 'ImportNamespaceSpecifier') {\n        // Importing everything, e.g. import * as t from 'typegpu';\n        ctx.tgpuAliases.add(`${spec.local.name}.tgpu`);\n      }\n    }\n  }\n}\n\nconst fnShellFunctionNames = ['fn', 'vertexFn', 'fragmentFn', 'computeFn'];\n\nexport function isShellImplementationCall(\n  node: acorn.CallExpression | babel.CallExpression,\n  ctx: Context,\n) {\n  return (\n    node.callee.type === 'CallExpression' &&\n    node.callee.callee.type === 'MemberExpression' &&\n    node.callee.callee.property.type === 'Identifier' &&\n    fnShellFunctionNames.includes(node.callee.callee.property.name) &&\n    node.arguments.length === 1 && isTgpu(ctx, node.callee.callee.object)\n  );\n}\n\nexport function getFunctionName(\n  node: acorn.AnyNode | babel.Node,\n  parent: acorn.AnyNode | babel.Node | null,\n): string | undefined {\n  if (\n    parent?.type === 'VariableDeclarator' && parent.id.type === 'Identifier'\n  ) {\n    return parent.id.name;\n  }\n  return node.type === 'FunctionDeclaration' ||\n      node.type === 'FunctionExpression'\n    ? node.id?.name\n    : undefined;\n}\n\nconst resourceConstructors: string[] = [\n  // tgpu\n  'bindGroupLayout',\n  'vertexLayout',\n  'privateVar',\n  'workgroupVar',\n  'const',\n  // tgpu['~unstable']\n  'slot',\n  'accessor',\n  'comptime',\n  ...fnShellFunctionNames,\n  // d\n  'struct',\n  'unstruct',\n  // root\n  'createBuffer',\n  'createMutable',\n  'createReadonly',\n  'createUniform',\n  'createQuerySet',\n  // root['~unstable']\n  'createPipeline',\n  'createGuardedComputePipeline',\n  'createTexture',\n  'createSampler',\n  'createComparisonSampler',\n];\n\n/**\n * Checks if `node` should be wrapped in an autoname function.\n * Since it is mostly for debugging and clean WGSL generation,\n * some false positives and false negatives are admissible.\n */\nfunction containsResourceConstructorCall(\n  node: acorn.AnyNode | babel.Node,\n  ctx: Context,\n) {\n  if (node.type === 'CallExpression') {\n    if (isShellImplementationCall(node, ctx)) {\n      return true;\n    }\n    // struct({...})\n    if (\n      node.callee.type === 'Identifier' &&\n      resourceConstructors.includes(node.callee.name)\n    ) {\n      return true;\n    }\n    if (node.callee.type === 'MemberExpression') {\n      if (node.callee.property.type === 'Identifier') {\n        // root.createBuffer({...})\n        if (resourceConstructors.includes(node.callee.property.name)) {\n          return true;\n        }\n        if (node.callee.property.name === '$name') {\n          return false;\n        }\n      }\n      // root.createBuffer(d.f32).$usage('storage')\n      return containsResourceConstructorCall(node.callee.object, ctx);\n    }\n  }\n  if (node.type === 'TaggedTemplateExpression') {\n    return containsResourceConstructorCall(node.tag, ctx);\n  }\n  return false;\n}\n\n/**\n * Tries to find an identifier in a node.\n *\n * @example\n * // syntax is simplified, imagine the arguments are appropriate nodes instead\n * tryFindIdentifier('myBuffer'); // 'myBuffer'\n * tryFindIdentifier('buffers.myBuffer'); // 'myBuffer'\n * tryFindIdentifier('this.myBuffer'); // 'myBuffer'\n * tryFindIdentifier('[a, b]'); // undefined\n */\nfunction tryFindIdentifier(\n  node: acorn.AnyNode | babel.Node,\n): string | undefined {\n  if (node.type === 'Identifier') {\n    return node.name;\n  }\n  if (node.type === 'MemberExpression') {\n    return tryFindIdentifier(node.property);\n  }\n}\n\ntype ExpressionFor<T extends acorn.AnyNode | babel.Node> = T extends\n  acorn.AnyNode ? acorn.Expression : babel.Expression;\n\n/**\n * Checks if `node` contains a label and a tgpu expression that could be named.\n * If so, it calls the provided callback. Nodes selected for naming include:\n *\n * `let name = tgpu.bindGroupLayout({});` (VariableDeclarator)\n *\n * `name = tgpu.bindGroupLayout({});` (AssignmentExpression)\n *\n * `property: tgpu.bindGroupLayout({})` (Property/ObjectProperty)\n *\n * Since it is mostly for debugging and clean WGSL generation,\n * some false positives and false negatives are admissible.\n *\n * This function is NOT used for auto-naming shell-less functions.\n * Those are handled separately.\n *\n * @privateRemarks\n * When adding new checks, you need to call this method in the corresponding node in Babel.\n */\nexport function performExpressionNaming<T extends acorn.AnyNode | babel.Node>(\n  ctx: Context,\n  node: T,\n  namingCallback: (node: ExpressionFor<T>, name: string) => void,\n) {\n  if (!ctx.autoNamingEnabled) {\n    return;\n  }\n\n  if (\n    node.type === 'VariableDeclarator' &&\n    node.id.type === 'Identifier' &&\n    node.init &&\n    containsResourceConstructorCall(node.init, ctx)\n  ) {\n    namingCallback(node.init as ExpressionFor<T>, node.id.name);\n  } else if (\n    node.type === 'AssignmentExpression' &&\n    containsResourceConstructorCall(node.right, ctx)\n  ) {\n    const maybeName = tryFindIdentifier(node.left);\n    if (maybeName) {\n      namingCallback(node.right as ExpressionFor<T>, maybeName);\n    }\n  } else if (\n    (node.type === 'Property' || node.type === 'ObjectProperty') &&\n    node.key.type === 'Identifier' &&\n    containsResourceConstructorCall(node.value, ctx)\n  ) {\n    namingCallback(node.value as ExpressionFor<T>, node.key.name);\n  } else if (\n    (node.type === 'ClassProperty' || node.type === 'PropertyDefinition') &&\n    node.value &&\n    node.key.type === 'Identifier' &&\n    containsResourceConstructorCall(node.value, ctx)\n  ) {\n    namingCallback(node.value as ExpressionFor<T>, node.key.name);\n  }\n}\n\nexport const useGpuDirective = 'use gpu';\n\n/** Regular expressions used for early pruning (to avoid unnecessary parsing, which is expensive) */\nexport const earlyPruneRegex = [/[\"']use gpu[\"']/, /t(ype)?gpu/];\n"]}