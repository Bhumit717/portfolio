{"version":3,"sources":["../src/parsers.ts"],"sourcesContent":["import type * as babel from '@babel/types';\nimport type * as acorn from 'acorn';\nimport * as tinyest from 'tinyest';\nimport { FuncParameterType } from 'tinyest';\n\nconst { NodeTypeCatalog: NODE } = tinyest;\n\ntype Scope = {\n  /** identifiers declared in this scope */\n  declaredNames: string[];\n};\n\ntype Context = {\n  /** Holds a set of all identifiers that were used in code, but were not declared in code. */\n  externalNames: Set<string>;\n  /** Used to signal to identifiers that they should not treat their resolution as possible external uses. */\n  ignoreExternalDepth: number;\n  stack: Scope[];\n};\n\ntype JsNode = babel.Node | acorn.AnyNode;\n\nfunction isDeclared(ctx: Context, name: string) {\n  return ctx.stack.some((scope) => scope.declaredNames.includes(name));\n}\n\nconst Transpilers: Partial<\n  {\n    [Type in JsNode['type']]: (\n      ctx: Context,\n      node: Extract<JsNode, { type: Type }>,\n    ) => tinyest.AnyNode;\n  }\n> = {\n  Program(ctx, node) {\n    const body = node.body[0];\n\n    if (!body) {\n      throw new Error('tgpu.fn was not implemented correctly.');\n    }\n\n    return transpile(ctx, body);\n  },\n\n  ExpressionStatement: (ctx, node) => transpile(ctx, node.expression),\n\n  ArrowFunctionExpression: (ctx, node) => {\n    throw new Error('Arrow functions are not supported inside TGSL.');\n  },\n\n  BlockStatement(ctx, node) {\n    ctx.stack.push({ declaredNames: [] });\n\n    const result = [\n      NODE.block,\n      node.body.map(\n        (statement) => transpile(ctx, statement) as tinyest.Statement,\n      ),\n    ] as const;\n\n    ctx.stack.pop();\n\n    return result;\n  },\n\n  ReturnStatement: (ctx, node) =>\n    node.argument\n      ? [NODE.return, transpile(ctx, node.argument) as tinyest.Expression]\n      : [NODE.return],\n\n  Identifier(ctx, node) {\n    if (ctx.ignoreExternalDepth === 0 && !isDeclared(ctx, node.name)) {\n      ctx.externalNames.add(node.name);\n    }\n\n    return node.name;\n  },\n\n  ThisExpression(ctx) {\n    ctx.externalNames.add('this');\n    return 'this';\n  },\n\n  BinaryExpression(ctx, node) {\n    const left = transpile(ctx, node.left) as tinyest.Expression;\n    const right = transpile(ctx, node.right) as tinyest.Expression;\n    return [\n      NODE.binaryExpr,\n      left,\n      node.operator as tinyest.BinaryOperator,\n      right,\n    ];\n  },\n\n  LogicalExpression(ctx, node) {\n    const left = transpile(ctx, node.left) as tinyest.Expression;\n    const right = transpile(ctx, node.right) as tinyest.Expression;\n    return [\n      NODE.logicalExpr,\n      left,\n      node.operator as tinyest.LogicalOperator,\n      right,\n    ];\n  },\n\n  AssignmentExpression(ctx, node) {\n    const left = transpile(ctx, node.left) as tinyest.Expression;\n    const right = transpile(ctx, node.right) as tinyest.Expression;\n    return [\n      NODE.assignmentExpr,\n      left,\n      node.operator as tinyest.AssignmentOperator,\n      right,\n    ];\n  },\n\n  UnaryExpression(ctx, node) {\n    const wgslOp = node.operator;\n    const argument = transpile(ctx, node.argument) as tinyest.Expression;\n    return [NODE.unaryExpr, wgslOp, argument] as tinyest.UnaryExpression;\n  },\n\n  MemberExpression(ctx, node) {\n    const object = transpile(ctx, node.object) as tinyest.Expression;\n\n    // If the property is computed, it could potentially be an external identifier.\n    if (node.computed) {\n      const property = transpile(ctx, node.property) as tinyest.Expression;\n      return [NODE.indexAccess, object, property];\n    }\n\n    // If the property is not computed, we don't want to register identifiers as external.\n    ctx.ignoreExternalDepth++;\n    const property = transpile(ctx, node.property) as tinyest.Expression;\n    ctx.ignoreExternalDepth--;\n\n    if (typeof property !== 'string') {\n      throw new Error('Expected identifier as property access key.');\n    }\n\n    return [NODE.memberAccess, object, property];\n  },\n\n  UpdateExpression(ctx, node) {\n    const operator = node.operator;\n    const argument = transpile(ctx, node.argument) as tinyest.Expression;\n    if (node.prefix) {\n      throw new Error('Prefix update expressions are not supported in WGSL.');\n    }\n    return [NODE.postUpdate, operator, argument];\n  },\n\n  Literal(ctx, node) {\n    if (typeof node.value === 'boolean') {\n      return node.value;\n    }\n    if (typeof node.value === 'string') {\n      return [NODE.stringLiteral, node.value];\n    }\n    if (node.regex) {\n      throw new Error(\n        'Regular expression literals are not representable in WGSL.',\n      );\n    }\n    if (node.bigint) {\n      console.warn(\n        'BigInt literals are represented as numbers - loss of precision may occur.',\n      );\n    }\n    return [NODE.numericLiteral, String(Number(node.value)) ?? ''];\n  },\n\n  NumericLiteral(ctx, node) {\n    return [NODE.numericLiteral, String(node.value) ?? ''];\n  },\n\n  BigIntLiteral(ctx, node) {\n    console.warn(\n      'BigInt literals are represented as numbers - loss of precision may occur.',\n    );\n    return [NODE.numericLiteral, String(Number.parseInt(node.value))];\n  },\n\n  BooleanLiteral(ctx, node) {\n    return node.value;\n  },\n\n  StringLiteral(ctx, node) {\n    return [NODE.stringLiteral, node.value];\n  },\n\n  CallExpression(ctx, node) {\n    const callee = transpile(ctx, node.callee) as tinyest.Expression;\n\n    const args = node.arguments.map((arg) =>\n      transpile(ctx, arg)\n    ) as tinyest.Expression[];\n\n    return [NODE.call, callee, args];\n  },\n\n  ArrayExpression: (ctx, node) => [\n    NODE.arrayExpr,\n    node.elements.map((elem) => {\n      if (!elem || elem.type === 'SpreadElement') {\n        throw new Error('Spread elements are not supported in TGSL.');\n      }\n      return transpile(ctx, elem) as tinyest.Expression;\n    }),\n  ],\n\n  VariableDeclaration(ctx, node) {\n    if (node.declarations.length !== 1 || !node.declarations[0]) {\n      throw new Error(\n        'Currently only one declaration in a statement is supported.',\n      );\n    }\n\n    const decl = node.declarations[0];\n    ctx.ignoreExternalDepth++;\n    const id = transpile(ctx, decl.id);\n    ctx.ignoreExternalDepth--;\n\n    if (typeof id !== 'string') {\n      throw new Error('Invalid variable declaration, expected identifier.');\n    }\n\n    ctx.stack[ctx.stack.length - 1]?.declaredNames.push(id);\n\n    const init = decl.init\n      ? (transpile(ctx, decl.init) as tinyest.Expression)\n      : undefined;\n\n    if (node.kind === 'var') {\n      throw new Error('`var` declarations are not supported.');\n    }\n\n    if (node.kind === 'const') {\n      if (init === undefined) {\n        throw new Error(\n          'Did not provide initial value in `const` declaration.',\n        );\n      }\n      return [NODE.const, id, init];\n    }\n\n    return init !== undefined ? [NODE.let, id, init] : [NODE.let, id];\n  },\n\n  IfStatement(ctx, node) {\n    const test = transpile(ctx, node.test) as tinyest.Expression;\n    const consequent = transpile(ctx, node.consequent) as tinyest.Statement;\n    const alternate = node.alternate\n      ? (transpile(ctx, node.alternate) as tinyest.Statement)\n      : undefined;\n\n    return alternate\n      ? [NODE.if, test, consequent, alternate]\n      : [NODE.if, test, consequent];\n  },\n\n  ObjectExpression(ctx, node) {\n    const properties: Record<string, tinyest.Expression> = {};\n\n    for (const prop of node.properties) {\n      // TODO: Handle SpreadElement\n      if (prop.type === 'SpreadElement') {\n        throw new Error('Spread elements are not supported in TGSL.');\n      }\n\n      // TODO: Handle computed properties\n      if (prop.key.type !== 'Identifier' && prop.key.type !== 'Literal') {\n        throw new Error(\n          'Only Identifier and Literal keys are supported as object keys.',\n        );\n      }\n\n      // TODO: Handle Object method\n      if (prop.type === 'ObjectMethod') {\n        throw new Error('Object method elements are not supported in TGSL.');\n      }\n\n      ctx.ignoreExternalDepth++;\n      const key = prop.key.type === 'Identifier'\n        ? (transpile(ctx, prop.key) as string)\n        : String(prop.key.value);\n      ctx.ignoreExternalDepth--;\n      const value = transpile(ctx, prop.value) as tinyest.Expression;\n\n      properties[key] = value;\n    }\n\n    return [NODE.objectExpr, properties];\n  },\n\n  ForStatement(ctx, node) {\n    const init = node.init\n      ? (transpile(ctx, node.init) as tinyest.Statement)\n      : null;\n    const condition = node.test\n      ? (transpile(ctx, node.test) as tinyest.Expression)\n      : null;\n    const update = node.update\n      ? (transpile(ctx, node.update) as tinyest.Statement)\n      : null;\n    const body = transpile(ctx, node.body) as tinyest.Statement;\n\n    return [NODE.for, init, condition, update, body];\n  },\n\n  WhileStatement(ctx, node) {\n    const condition = transpile(ctx, node.test) as tinyest.Expression;\n    const body = transpile(ctx, node.body) as tinyest.Statement;\n    return [NODE.while, condition, body];\n  },\n\n  ContinueStatement() {\n    return [NODE.continue];\n  },\n\n  BreakStatement() {\n    return [NODE.break];\n  },\n\n  TSAsExpression(ctx, node) {\n    return transpile(ctx, node.expression);\n  },\n\n  TSSatisfiesExpression(ctx, node) {\n    return transpile(ctx, node.expression);\n  },\n};\n\nfunction transpile(ctx: Context, node: JsNode): tinyest.AnyNode {\n  const transpiler = Transpilers[node.type];\n\n  if (!transpiler) {\n    throw new Error(`Unsupported JS functionality: ${node.type}`);\n  }\n\n  // @ts-expect-error <too much for typescript, it seems :/ >\n  return transpiler(ctx, node);\n}\n\nexport type TranspilationResult = {\n  params: tinyest.FuncParameter[];\n  body: tinyest.Block;\n  /**\n   * All identifiers found in the function code that are not declared in the\n   * function itself, or in the block that is accessing that identifier.\n   */\n  externalNames: string[];\n};\n\nexport function extractFunctionParts(rootNode: JsNode): {\n  params: tinyest.FuncParameter[];\n  body:\n    | acorn.BlockStatement\n    | acorn.Expression\n    | babel.BlockStatement\n    | babel.Expression;\n} {\n  let functionNode:\n    | acorn.ArrowFunctionExpression\n    | acorn.FunctionExpression\n    | acorn.FunctionDeclaration\n    | acorn.AnonymousFunctionDeclaration\n    | babel.ArrowFunctionExpression\n    | babel.FunctionExpression\n    | babel.FunctionDeclaration\n    | null = null;\n\n  // Unwrapping until we get to a function\n  let unwrappedNode = rootNode;\n  while (true) {\n    if (unwrappedNode.type === 'Program') {\n      const statement = unwrappedNode.body.filter(\n        (n) =>\n          n.type === 'ExpressionStatement' || n.type === 'FunctionDeclaration',\n      )[0]; // <- assuming only one function declaration\n\n      if (!statement) {\n        break;\n      }\n\n      unwrappedNode = statement;\n    } else if (unwrappedNode.type === 'ExpressionStatement') {\n      unwrappedNode = unwrappedNode.expression;\n    } else if (unwrappedNode.type === 'ArrowFunctionExpression') {\n      functionNode = unwrappedNode;\n      break; // We got a function\n    } else if (unwrappedNode.type === 'FunctionExpression') {\n      functionNode = unwrappedNode;\n      break; // We got a function\n    } else if (unwrappedNode.type === 'FunctionDeclaration') {\n      functionNode = unwrappedNode;\n      break; // We got a function\n    } else {\n      // Unsupported node\n      break;\n    }\n  }\n\n  if (!functionNode) {\n    throw new Error(\n      `tgpu.fn expected a single function to be passed as implementation ${\n        JSON.stringify(unwrappedNode)\n      }`,\n    );\n  }\n\n  if (functionNode.async) {\n    throw new Error('tgpu.fn cannot be async');\n  }\n\n  if (functionNode.generator) {\n    throw new Error('tgpu.fn cannot be a generator');\n  }\n\n  const unsupportedTypes = new Set(\n    functionNode.params.flatMap((param) =>\n      param.type === 'ObjectPattern' || param.type === 'Identifier'\n        ? []\n        : [param.type]\n    ),\n  );\n  if (unsupportedTypes.size > 0) {\n    throw new Error(\n      `Unsupported function parameter type(s): ${[...unsupportedTypes]}`,\n    );\n  }\n\n  return {\n    params: (functionNode\n      .params as (\n        | babel.Identifier\n        | acorn.Identifier\n        | babel.ObjectPattern\n        | acorn.ObjectPattern\n      )[]).map((param) =>\n        param.type === 'ObjectPattern'\n          ? {\n            type: FuncParameterType.destructuredObject,\n            props: param.properties.flatMap((prop) =>\n              (prop.type === 'Property' || prop.type === 'ObjectProperty') &&\n                prop.key.type === 'Identifier' &&\n                prop.value.type === 'Identifier'\n                ? [{ name: prop.key.name, alias: prop.value.name }]\n                : []\n            ),\n          }\n          : {\n            type: FuncParameterType.identifier,\n            name: param.name,\n          }\n      ),\n    body: functionNode.body,\n  };\n}\n\nexport function transpileFn(rootNode: JsNode): TranspilationResult {\n  const { params, body } = extractFunctionParts(rootNode);\n\n  const ctx: Context = {\n    externalNames: new Set(),\n    ignoreExternalDepth: 0,\n    stack: [\n      {\n        declaredNames: params.flatMap((param) =>\n          param.type === FuncParameterType.identifier\n            ? param.name\n            : param.props.map((prop) => prop.alias)\n        ),\n      },\n    ],\n  };\n\n  const tinyestBody = transpile(ctx, body);\n  const externalNames = [...ctx.externalNames];\n\n  if (body.type === 'BlockStatement') {\n    return {\n      params,\n      body: tinyestBody as tinyest.Block,\n      externalNames,\n    };\n  }\n\n  return {\n    params,\n    body: [NODE.block, [[NODE.return, tinyestBody as tinyest.Expression]]],\n    externalNames,\n  };\n}\n\nexport function transpileNode(node: JsNode): tinyest.AnyNode {\n  const ctx: Context = {\n    externalNames: new Set(),\n    ignoreExternalDepth: 0,\n    stack: [\n      {\n        declaredNames: [],\n      },\n    ],\n  };\n\n  return transpile(ctx, node);\n}\n"],"mappings":"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","names":["tinyest","FuncParameterType","NODE","isDeclared","ctx","name","scope","Transpilers","node","body","transpile","result","statement","left","right","wgslOp","argument","object","property","operator","_a","callee","args","arg","elem","decl","id","init","test","consequent","alternate","properties","prop","key","value","condition","update","transpiler","extractFunctionParts","rootNode","functionNode","unwrappedNode","n","unsupportedTypes","param","transpileFn","params","tinyestBody","externalNames","transpileNode"]}