{"version":3,"sources":["../src/parsers.ts"],"names":["NODE","tinyest","isDeclared","ctx","name","scope","Transpilers","node","body","transpile","result","statement","left","right","wgslOp","argument","object","property","operator","_a","callee","args","arg","elem","decl","id","init","test","consequent","alternate","properties","prop","key","value","condition","update","transpiler"],"mappings":"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","file":"/Users/iwo/Projects/wigsill/packages/tinyest-for-wgsl/dist/index.cjs","sourcesContent":["import type * as babel from '@babel/types';\nimport type * as acorn from 'acorn';\nimport * as tinyest from 'tinyest';\nimport { FuncParameterType } from 'tinyest';\n\nconst { NodeTypeCatalog: NODE } = tinyest;\n\ntype Scope = {\n  /** identifiers declared in this scope */\n  declaredNames: string[];\n};\n\ntype Context = {\n  /** Holds a set of all identifiers that were used in code, but were not declared in code. */\n  externalNames: Set<string>;\n  /** Used to signal to identifiers that they should not treat their resolution as possible external uses. */\n  ignoreExternalDepth: number;\n  stack: Scope[];\n};\n\ntype JsNode = babel.Node | acorn.AnyNode;\n\nfunction isDeclared(ctx: Context, name: string) {\n  return ctx.stack.some((scope) => scope.declaredNames.includes(name));\n}\n\nconst Transpilers: Partial<\n  {\n    [Type in JsNode['type']]: (\n      ctx: Context,\n      node: Extract<JsNode, { type: Type }>,\n    ) => tinyest.AnyNode;\n  }\n> = {\n  Program(ctx, node) {\n    const body = node.body[0];\n\n    if (!body) {\n      throw new Error('tgpu.fn was not implemented correctly.');\n    }\n\n    return transpile(ctx, body);\n  },\n\n  ExpressionStatement: (ctx, node) => transpile(ctx, node.expression),\n\n  ArrowFunctionExpression: (ctx, node) => {\n    throw new Error('Arrow functions are not supported inside TGSL.');\n  },\n\n  BlockStatement(ctx, node) {\n    ctx.stack.push({ declaredNames: [] });\n\n    const result = [\n      NODE.block,\n      node.body.map(\n        (statement) => transpile(ctx, statement) as tinyest.Statement,\n      ),\n    ] as const;\n\n    ctx.stack.pop();\n\n    return result;\n  },\n\n  ReturnStatement: (ctx, node) =>\n    node.argument\n      ? [NODE.return, transpile(ctx, node.argument) as tinyest.Expression]\n      : [NODE.return],\n\n  Identifier(ctx, node) {\n    if (ctx.ignoreExternalDepth === 0 && !isDeclared(ctx, node.name)) {\n      ctx.externalNames.add(node.name);\n    }\n\n    return node.name;\n  },\n\n  ThisExpression(ctx) {\n    ctx.externalNames.add('this');\n    return 'this';\n  },\n\n  BinaryExpression(ctx, node) {\n    const left = transpile(ctx, node.left) as tinyest.Expression;\n    const right = transpile(ctx, node.right) as tinyest.Expression;\n    return [\n      NODE.binaryExpr,\n      left,\n      node.operator as tinyest.BinaryOperator,\n      right,\n    ];\n  },\n\n  LogicalExpression(ctx, node) {\n    const left = transpile(ctx, node.left) as tinyest.Expression;\n    const right = transpile(ctx, node.right) as tinyest.Expression;\n    return [\n      NODE.logicalExpr,\n      left,\n      node.operator as tinyest.LogicalOperator,\n      right,\n    ];\n  },\n\n  AssignmentExpression(ctx, node) {\n    const left = transpile(ctx, node.left) as tinyest.Expression;\n    const right = transpile(ctx, node.right) as tinyest.Expression;\n    return [\n      NODE.assignmentExpr,\n      left,\n      node.operator as tinyest.AssignmentOperator,\n      right,\n    ];\n  },\n\n  UnaryExpression(ctx, node) {\n    const wgslOp = node.operator;\n    const argument = transpile(ctx, node.argument) as tinyest.Expression;\n    return [NODE.unaryExpr, wgslOp, argument] as tinyest.UnaryExpression;\n  },\n\n  MemberExpression(ctx, node) {\n    const object = transpile(ctx, node.object) as tinyest.Expression;\n\n    // If the property is computed, it could potentially be an external identifier.\n    if (node.computed) {\n      const property = transpile(ctx, node.property) as tinyest.Expression;\n      return [NODE.indexAccess, object, property];\n    }\n\n    // If the property is not computed, we don't want to register identifiers as external.\n    ctx.ignoreExternalDepth++;\n    const property = transpile(ctx, node.property) as tinyest.Expression;\n    ctx.ignoreExternalDepth--;\n\n    if (typeof property !== 'string') {\n      throw new Error('Expected identifier as property access key.');\n    }\n\n    return [NODE.memberAccess, object, property];\n  },\n\n  UpdateExpression(ctx, node) {\n    const operator = node.operator;\n    const argument = transpile(ctx, node.argument) as tinyest.Expression;\n    if (node.prefix) {\n      throw new Error('Prefix update expressions are not supported in WGSL.');\n    }\n    return [NODE.postUpdate, operator, argument];\n  },\n\n  Literal(ctx, node) {\n    if (typeof node.value === 'boolean') {\n      return node.value;\n    }\n    if (typeof node.value === 'string') {\n      return [NODE.stringLiteral, node.value];\n    }\n    if (node.regex) {\n      throw new Error(\n        'Regular expression literals are not representable in WGSL.',\n      );\n    }\n    if (node.bigint) {\n      console.warn(\n        'BigInt literals are represented as numbers - loss of precision may occur.',\n      );\n    }\n    return [NODE.numericLiteral, String(Number(node.value)) ?? ''];\n  },\n\n  NumericLiteral(ctx, node) {\n    return [NODE.numericLiteral, String(node.value) ?? ''];\n  },\n\n  BigIntLiteral(ctx, node) {\n    console.warn(\n      'BigInt literals are represented as numbers - loss of precision may occur.',\n    );\n    return [NODE.numericLiteral, String(Number.parseInt(node.value))];\n  },\n\n  BooleanLiteral(ctx, node) {\n    return node.value;\n  },\n\n  StringLiteral(ctx, node) {\n    return [NODE.stringLiteral, node.value];\n  },\n\n  CallExpression(ctx, node) {\n    const callee = transpile(ctx, node.callee) as tinyest.Expression;\n\n    const args = node.arguments.map((arg) =>\n      transpile(ctx, arg)\n    ) as tinyest.Expression[];\n\n    return [NODE.call, callee, args];\n  },\n\n  ArrayExpression: (ctx, node) => [\n    NODE.arrayExpr,\n    node.elements.map((elem) => {\n      if (!elem || elem.type === 'SpreadElement') {\n        throw new Error('Spread elements are not supported in TGSL.');\n      }\n      return transpile(ctx, elem) as tinyest.Expression;\n    }),\n  ],\n\n  VariableDeclaration(ctx, node) {\n    if (node.declarations.length !== 1 || !node.declarations[0]) {\n      throw new Error(\n        'Currently only one declaration in a statement is supported.',\n      );\n    }\n\n    const decl = node.declarations[0];\n    ctx.ignoreExternalDepth++;\n    const id = transpile(ctx, decl.id);\n    ctx.ignoreExternalDepth--;\n\n    if (typeof id !== 'string') {\n      throw new Error('Invalid variable declaration, expected identifier.');\n    }\n\n    ctx.stack[ctx.stack.length - 1]?.declaredNames.push(id);\n\n    const init = decl.init\n      ? (transpile(ctx, decl.init) as tinyest.Expression)\n      : undefined;\n\n    if (node.kind === 'var') {\n      throw new Error('`var` declarations are not supported.');\n    }\n\n    if (node.kind === 'const') {\n      if (init === undefined) {\n        throw new Error(\n          'Did not provide initial value in `const` declaration.',\n        );\n      }\n      return [NODE.const, id, init];\n    }\n\n    return init !== undefined ? [NODE.let, id, init] : [NODE.let, id];\n  },\n\n  IfStatement(ctx, node) {\n    const test = transpile(ctx, node.test) as tinyest.Expression;\n    const consequent = transpile(ctx, node.consequent) as tinyest.Statement;\n    const alternate = node.alternate\n      ? (transpile(ctx, node.alternate) as tinyest.Statement)\n      : undefined;\n\n    return alternate\n      ? [NODE.if, test, consequent, alternate]\n      : [NODE.if, test, consequent];\n  },\n\n  ObjectExpression(ctx, node) {\n    const properties: Record<string, tinyest.Expression> = {};\n\n    for (const prop of node.properties) {\n      // TODO: Handle SpreadElement\n      if (prop.type === 'SpreadElement') {\n        throw new Error('Spread elements are not supported in TGSL.');\n      }\n\n      // TODO: Handle computed properties\n      if (prop.key.type !== 'Identifier' && prop.key.type !== 'Literal') {\n        throw new Error(\n          'Only Identifier and Literal keys are supported as object keys.',\n        );\n      }\n\n      // TODO: Handle Object method\n      if (prop.type === 'ObjectMethod') {\n        throw new Error('Object method elements are not supported in TGSL.');\n      }\n\n      ctx.ignoreExternalDepth++;\n      const key = prop.key.type === 'Identifier'\n        ? (transpile(ctx, prop.key) as string)\n        : String(prop.key.value);\n      ctx.ignoreExternalDepth--;\n      const value = transpile(ctx, prop.value) as tinyest.Expression;\n\n      properties[key] = value;\n    }\n\n    return [NODE.objectExpr, properties];\n  },\n\n  ForStatement(ctx, node) {\n    const init = node.init\n      ? (transpile(ctx, node.init) as tinyest.Statement)\n      : null;\n    const condition = node.test\n      ? (transpile(ctx, node.test) as tinyest.Expression)\n      : null;\n    const update = node.update\n      ? (transpile(ctx, node.update) as tinyest.Statement)\n      : null;\n    const body = transpile(ctx, node.body) as tinyest.Statement;\n\n    return [NODE.for, init, condition, update, body];\n  },\n\n  WhileStatement(ctx, node) {\n    const condition = transpile(ctx, node.test) as tinyest.Expression;\n    const body = transpile(ctx, node.body) as tinyest.Statement;\n    return [NODE.while, condition, body];\n  },\n\n  ContinueStatement() {\n    return [NODE.continue];\n  },\n\n  BreakStatement() {\n    return [NODE.break];\n  },\n\n  TSAsExpression(ctx, node) {\n    return transpile(ctx, node.expression);\n  },\n\n  TSSatisfiesExpression(ctx, node) {\n    return transpile(ctx, node.expression);\n  },\n};\n\nfunction transpile(ctx: Context, node: JsNode): tinyest.AnyNode {\n  const transpiler = Transpilers[node.type];\n\n  if (!transpiler) {\n    throw new Error(`Unsupported JS functionality: ${node.type}`);\n  }\n\n  // @ts-expect-error <too much for typescript, it seems :/ >\n  return transpiler(ctx, node);\n}\n\nexport type TranspilationResult = {\n  params: tinyest.FuncParameter[];\n  body: tinyest.Block;\n  /**\n   * All identifiers found in the function code that are not declared in the\n   * function itself, or in the block that is accessing that identifier.\n   */\n  externalNames: string[];\n};\n\nexport function extractFunctionParts(rootNode: JsNode): {\n  params: tinyest.FuncParameter[];\n  body:\n    | acorn.BlockStatement\n    | acorn.Expression\n    | babel.BlockStatement\n    | babel.Expression;\n} {\n  let functionNode:\n    | acorn.ArrowFunctionExpression\n    | acorn.FunctionExpression\n    | acorn.FunctionDeclaration\n    | acorn.AnonymousFunctionDeclaration\n    | babel.ArrowFunctionExpression\n    | babel.FunctionExpression\n    | babel.FunctionDeclaration\n    | null = null;\n\n  // Unwrapping until we get to a function\n  let unwrappedNode = rootNode;\n  while (true) {\n    if (unwrappedNode.type === 'Program') {\n      const statement = unwrappedNode.body.filter(\n        (n) =>\n          n.type === 'ExpressionStatement' || n.type === 'FunctionDeclaration',\n      )[0]; // <- assuming only one function declaration\n\n      if (!statement) {\n        break;\n      }\n\n      unwrappedNode = statement;\n    } else if (unwrappedNode.type === 'ExpressionStatement') {\n      unwrappedNode = unwrappedNode.expression;\n    } else if (unwrappedNode.type === 'ArrowFunctionExpression') {\n      functionNode = unwrappedNode;\n      break; // We got a function\n    } else if (unwrappedNode.type === 'FunctionExpression') {\n      functionNode = unwrappedNode;\n      break; // We got a function\n    } else if (unwrappedNode.type === 'FunctionDeclaration') {\n      functionNode = unwrappedNode;\n      break; // We got a function\n    } else {\n      // Unsupported node\n      break;\n    }\n  }\n\n  if (!functionNode) {\n    throw new Error(\n      `tgpu.fn expected a single function to be passed as implementation ${\n        JSON.stringify(unwrappedNode)\n      }`,\n    );\n  }\n\n  if (functionNode.async) {\n    throw new Error('tgpu.fn cannot be async');\n  }\n\n  if (functionNode.generator) {\n    throw new Error('tgpu.fn cannot be a generator');\n  }\n\n  const unsupportedTypes = new Set(\n    functionNode.params.flatMap((param) =>\n      param.type === 'ObjectPattern' || param.type === 'Identifier'\n        ? []\n        : [param.type]\n    ),\n  );\n  if (unsupportedTypes.size > 0) {\n    throw new Error(\n      `Unsupported function parameter type(s): ${[...unsupportedTypes]}`,\n    );\n  }\n\n  return {\n    params: (functionNode\n      .params as (\n        | babel.Identifier\n        | acorn.Identifier\n        | babel.ObjectPattern\n        | acorn.ObjectPattern\n      )[]).map((param) =>\n        param.type === 'ObjectPattern'\n          ? {\n            type: FuncParameterType.destructuredObject,\n            props: param.properties.flatMap((prop) =>\n              (prop.type === 'Property' || prop.type === 'ObjectProperty') &&\n                prop.key.type === 'Identifier' &&\n                prop.value.type === 'Identifier'\n                ? [{ name: prop.key.name, alias: prop.value.name }]\n                : []\n            ),\n          }\n          : {\n            type: FuncParameterType.identifier,\n            name: param.name,\n          }\n      ),\n    body: functionNode.body,\n  };\n}\n\nexport function transpileFn(rootNode: JsNode): TranspilationResult {\n  const { params, body } = extractFunctionParts(rootNode);\n\n  const ctx: Context = {\n    externalNames: new Set(),\n    ignoreExternalDepth: 0,\n    stack: [\n      {\n        declaredNames: params.flatMap((param) =>\n          param.type === FuncParameterType.identifier\n            ? param.name\n            : param.props.map((prop) => prop.alias)\n        ),\n      },\n    ],\n  };\n\n  const tinyestBody = transpile(ctx, body);\n  const externalNames = [...ctx.externalNames];\n\n  if (body.type === 'BlockStatement') {\n    return {\n      params,\n      body: tinyestBody as tinyest.Block,\n      externalNames,\n    };\n  }\n\n  return {\n    params,\n    body: [NODE.block, [[NODE.return, tinyestBody as tinyest.Expression]]],\n    externalNames,\n  };\n}\n\nexport function transpileNode(node: JsNode): tinyest.AnyNode {\n  const ctx: Context = {\n    externalNames: new Set(),\n    ignoreExternalDepth: 0,\n    stack: [\n      {\n        declaredNames: [],\n      },\n    ],\n  };\n\n  return transpile(ctx, node);\n}\n"]}