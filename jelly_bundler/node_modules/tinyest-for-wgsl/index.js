import*as u from"tinyest";import{FuncParameterType as l}from"tinyest";var{NodeTypeCatalog:a}=u;function y(t,e){return t.stack.some(r=>r.declaredNames.includes(e))}var m={Program(t,e){let r=e.body[0];if(!r)throw new Error("tgpu.fn was not implemented correctly.");return s(t,r)},ExpressionStatement:(t,e)=>s(t,e.expression),ArrowFunctionExpression:(t,e)=>{throw new Error("Arrow functions are not supported inside TGSL.")},BlockStatement(t,e){t.stack.push({declaredNames:[]});let r=[a.block,e.body.map(n=>s(t,n))];return t.stack.pop(),r},ReturnStatement:(t,e)=>e.argument?[a.return,s(t,e.argument)]:[a.return],Identifier(t,e){return t.ignoreExternalDepth===0&&!y(t,e.name)&&t.externalNames.add(e.name),e.name},ThisExpression(t){return t.externalNames.add("this"),"this"},BinaryExpression(t,e){let r=s(t,e.left),n=s(t,e.right);return[a.binaryExpr,r,e.operator,n]},LogicalExpression(t,e){let r=s(t,e.left),n=s(t,e.right);return[a.logicalExpr,r,e.operator,n]},AssignmentExpression(t,e){let r=s(t,e.left),n=s(t,e.right);return[a.assignmentExpr,r,e.operator,n]},UnaryExpression(t,e){let r=e.operator,n=s(t,e.argument);return[a.unaryExpr,r,n]},MemberExpression(t,e){let r=s(t,e.object);if(e.computed){let i=s(t,e.property);return[a.indexAccess,r,i]}t.ignoreExternalDepth++;let n=s(t,e.property);if(t.ignoreExternalDepth--,typeof n!="string")throw new Error("Expected identifier as property access key.");return[a.memberAccess,r,n]},UpdateExpression(t,e){let r=e.operator,n=s(t,e.argument);if(e.prefix)throw new Error("Prefix update expressions are not supported in WGSL.");return[a.postUpdate,r,n]},Literal(t,e){var r;if(typeof e.value=="boolean")return e.value;if(typeof e.value=="string")return[a.stringLiteral,e.value];if(e.regex)throw new Error("Regular expression literals are not representable in WGSL.");return e.bigint&&console.warn("BigInt literals are represented as numbers - loss of precision may occur."),[a.numericLiteral,(r=String(Number(e.value)))!=null?r:""]},NumericLiteral(t,e){var r;return[a.numericLiteral,(r=String(e.value))!=null?r:""]},BigIntLiteral(t,e){return console.warn("BigInt literals are represented as numbers - loss of precision may occur."),[a.numericLiteral,String(Number.parseInt(e.value))]},BooleanLiteral(t,e){return e.value},StringLiteral(t,e){return[a.stringLiteral,e.value]},CallExpression(t,e){let r=s(t,e.callee),n=e.arguments.map(i=>s(t,i));return[a.call,r,n]},ArrayExpression:(t,e)=>[a.arrayExpr,e.elements.map(r=>{if(!r||r.type==="SpreadElement")throw new Error("Spread elements are not supported in TGSL.");return s(t,r)})],VariableDeclaration(t,e){var o;if(e.declarations.length!==1||!e.declarations[0])throw new Error("Currently only one declaration in a statement is supported.");let r=e.declarations[0];t.ignoreExternalDepth++;let n=s(t,r.id);if(t.ignoreExternalDepth--,typeof n!="string")throw new Error("Invalid variable declaration, expected identifier.");(o=t.stack[t.stack.length-1])==null||o.declaredNames.push(n);let i=r.init?s(t,r.init):void 0;if(e.kind==="var")throw new Error("`var` declarations are not supported.");if(e.kind==="const"){if(i===void 0)throw new Error("Did not provide initial value in `const` declaration.");return[a.const,n,i]}return i!==void 0?[a.let,n,i]:[a.let,n]},IfStatement(t,e){let r=s(t,e.test),n=s(t,e.consequent),i=e.alternate?s(t,e.alternate):void 0;return i?[a.if,r,n,i]:[a.if,r,n]},ObjectExpression(t,e){let r={};for(let n of e.properties){if(n.type==="SpreadElement")throw new Error("Spread elements are not supported in TGSL.");if(n.key.type!=="Identifier"&&n.key.type!=="Literal")throw new Error("Only Identifier and Literal keys are supported as object keys.");if(n.type==="ObjectMethod")throw new Error("Object method elements are not supported in TGSL.");t.ignoreExternalDepth++;let i=n.key.type==="Identifier"?s(t,n.key):String(n.key.value);t.ignoreExternalDepth--;let o=s(t,n.value);r[i]=o}return[a.objectExpr,r]},ForStatement(t,e){let r=e.init?s(t,e.init):null,n=e.test?s(t,e.test):null,i=e.update?s(t,e.update):null,o=s(t,e.body);return[a.for,r,n,i,o]},WhileStatement(t,e){let r=s(t,e.test),n=s(t,e.body);return[a.while,r,n]},ContinueStatement(){return[a.continue]},BreakStatement(){return[a.break]},TSAsExpression(t,e){return s(t,e.expression)},TSSatisfiesExpression(t,e){return s(t,e.expression)}};function s(t,e){let r=m[e.type];if(!r)throw new Error(`Unsupported JS functionality: ${e.type}`);return r(t,e)}function f(t){let e=null,r=t;for(;;)if(r.type==="Program"){let i=r.body.filter(o=>o.type==="ExpressionStatement"||o.type==="FunctionDeclaration")[0];if(!i)break;r=i}else if(r.type==="ExpressionStatement")r=r.expression;else if(r.type==="ArrowFunctionExpression"){e=r;break}else if(r.type==="FunctionExpression"){e=r;break}else if(r.type==="FunctionDeclaration"){e=r;break}else break;if(!e)throw new Error(`tgpu.fn expected a single function to be passed as implementation ${JSON.stringify(r)}`);if(e.async)throw new Error("tgpu.fn cannot be async");if(e.generator)throw new Error("tgpu.fn cannot be a generator");let n=new Set(e.params.flatMap(i=>i.type==="ObjectPattern"||i.type==="Identifier"?[]:[i.type]));if(n.size>0)throw new Error(`Unsupported function parameter type(s): ${[...n]}`);return{params:e.params.map(i=>i.type==="ObjectPattern"?{type:l.destructuredObject,props:i.properties.flatMap(o=>(o.type==="Property"||o.type==="ObjectProperty")&&o.key.type==="Identifier"&&o.value.type==="Identifier"?[{name:o.key.name,alias:o.value.name}]:[])}:{type:l.identifier,name:i.name}),body:e.body}}function d(t){let{params:e,body:r}=f(t),n={externalNames:new Set,ignoreExternalDepth:0,stack:[{declaredNames:e.flatMap(p=>p.type===l.identifier?p.name:p.props.map(c=>c.alias))}]},i=s(n,r),o=[...n.externalNames];return r.type==="BlockStatement"?{params:e,body:i,externalNames:o}:{params:e,body:[a.block,[[a.return,i]]],externalNames:o}}function E(t){return s({externalNames:new Set,ignoreExternalDepth:0,stack:[{declaredNames:[]}]},t)}export{d as transpileFn,E as transpileNode};
//# sourceMappingURL=index.js.map