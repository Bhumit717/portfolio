import tgpu from 'typegpu';
import * as d from 'typegpu/data';
import { dot, fract, cos, add, sqrt, sin, normalize, pow, mul, sign, select, step, tan, log, length, sub, floor, allEq, mix } from 'typegpu/std';

const randomGeneratorShell = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([], d.f32), "randomGeneratorShell"));
const BPETER = (() => {
  const seed = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.privateVar(d.vec2f), "seed"));
  return {
    seed: ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.f32])((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((value) => {
      seed.value = d.vec2f(value, 0);
    }), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"value"}],"body":[0,[[2,[7,"seed","value"],"=",[6,[7,"d","vec2f"],["value",[5,"0"]]]]]],"externalNames":["seed","d"]},
              externals: () => ({seed, d}),
            }) && $.f)({}))), "seed")),
    seed2: ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec2f])((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((value) => {
      seed.value = d.vec2f(value);
    }), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"value"}],"body":[0,[[2,[7,"seed","value"],"=",[6,[7,"d","vec2f"],["value"]]]]],"externalNames":["seed","d"]},
              externals: () => ({seed, d}),
            }) && $.f)({}))), "seed2")),
    seed3: ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec3f])((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((value) => {
      seed.value = add(value.xy, d.vec2f(value.z));
    }), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"value"}],"body":[0,[[2,[7,"seed","value"],"=",[6,"add",[[7,"value","xy"],[6,[7,"d","vec2f"],[[7,"value","z"]]]]]]]],"externalNames":["seed","add","d"]},
              externals: () => ({seed, add, d}),
            }) && $.f)({}))), "seed3")),
    seed4: ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec4f])((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((value) => {
      seed.value = add(value.xy, value.zw);
    }), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"value"}],"body":[0,[[2,[7,"seed","value"],"=",[6,"add",[[7,"value","xy"],[7,"value","zw"]]]]]],"externalNames":["seed","add"]},
              externals: () => ({seed, add}),
            }) && $.f)({}))), "seed4")),
    sample: randomGeneratorShell((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = (() => {
      "use gpu";
      const a = dot(seed.value, d.vec2f(23.14077926, 232.61690225));
      const b = dot(seed.value, d.vec2f(54.47856553, 345.84153136));
      seed.value.x = fract(cos(a) * 136.8168);
      seed.value.y = fract(cos(b) * 534.7645);
      return seed.value.y;
    }), {
              v: 1,
              name: undefined,
              ast: {"params":[],"body":[0,[[13,"a",[6,"dot",[[7,"seed","value"],[6,[7,"d","vec2f"],[[5,"23.14077926"],[5,"232.61690225"]]]]]],[13,"b",[6,"dot",[[7,"seed","value"],[6,[7,"d","vec2f"],[[5,"54.47856553"],[5,"345.84153136"]]]]]],[2,[7,[7,"seed","value"],"x"],"=",[6,"fract",[[1,[6,"cos",["a"]],"*",[5,"136.8168"]]]]],[2,[7,[7,"seed","value"],"y"],"=",[6,"fract",[[1,[6,"cos",["b"]],"*",[5,"534.7645"]]]]],[10,[7,[7,"seed","value"],"y"]]]],"externalNames":["dot","seed","d","fract","cos"]},
              externals: () => ({dot, seed, d, fract, cos}),
            }) && $.f)({})))
  };
})();
const DefaultGenerator = BPETER;
const randomGeneratorSlot = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.slot(
  DefaultGenerator
), "randomGeneratorSlot"));

const TWO_PI = Math.PI * 2;
const EPS = 1e-7;
const randSeed = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.f32])((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((seed) => {
  randomGeneratorSlot.value.seed(seed);
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"seed"}],"body":[0,[[6,[7,[7,"randomGeneratorSlot","value"],"seed"],["seed"]]]],"externalNames":["randomGeneratorSlot"]},
              externals: () => ({randomGeneratorSlot}),
            }) && $.f)({}))), "randSeed"));
const randSeed2 = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec2f])((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((seed) => {
  randomGeneratorSlot.value.seed2(seed);
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"seed"}],"body":[0,[[6,[7,[7,"randomGeneratorSlot","value"],"seed2"],["seed"]]]],"externalNames":["randomGeneratorSlot"]},
              externals: () => ({randomGeneratorSlot}),
            }) && $.f)({}))), "randSeed2"));
const randSeed3 = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec3f])((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((seed) => {
  randomGeneratorSlot.value.seed3(seed);
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"seed"}],"body":[0,[[6,[7,[7,"randomGeneratorSlot","value"],"seed3"],["seed"]]]],"externalNames":["randomGeneratorSlot"]},
              externals: () => ({randomGeneratorSlot}),
            }) && $.f)({}))), "randSeed3"));
const randSeed4 = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec4f])((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((seed) => {
  randomGeneratorSlot.value.seed4(seed);
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"seed"}],"body":[0,[[6,[7,[7,"randomGeneratorSlot","value"],"seed4"],["seed"]]]],"externalNames":["randomGeneratorSlot"]},
              externals: () => ({randomGeneratorSlot}),
            }) && $.f)({}))), "randSeed4"));
const randFloat01 = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([], d.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = (() => randomGeneratorSlot.value.sample()), {
              v: 1,
              name: undefined,
              ast: {"params":[],"body":[0,[[10,[6,[7,[7,"randomGeneratorSlot","value"],"sample"],[]]]]],"externalNames":["randomGeneratorSlot"]},
              externals: () => ({randomGeneratorSlot}),
            }) && $.f)({}))), "randFloat01"));
const randInUnitCube = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([], d.vec3f)(
  (($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = (() => d.vec3f(
    randomGeneratorSlot.value.sample(),
    randomGeneratorSlot.value.sample(),
    randomGeneratorSlot.value.sample()
  )), {
              v: 1,
              name: undefined,
              ast: {"params":[],"body":[0,[[10,[6,[7,"d","vec3f"],[[6,[7,[7,"randomGeneratorSlot","value"],"sample"],[]],[6,[7,[7,"randomGeneratorSlot","value"],"sample"],[]],[6,[7,[7,"randomGeneratorSlot","value"],"sample"],[]]]]]]],"externalNames":["d","randomGeneratorSlot"]},
              externals: () => ({d, randomGeneratorSlot}),
            }) && $.f)({}))
), "randInUnitCube"));
const randOnUnitCube = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([], d.vec3f)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = (() => {
  const face = d.u32(randomGeneratorSlot.value.sample() * 6);
  const axis = face % 3;
  const result = d.vec3f();
  result[axis] = d.f32(select(0, 1, face > 2));
  result[(axis + 1) % 3] = randomGeneratorSlot.value.sample();
  result[(axis + 2) % 3] = randomGeneratorSlot.value.sample();
  return result;
}), {
              v: 1,
              name: undefined,
              ast: {"params":[],"body":[0,[[13,"face",[6,[7,"d","u32"],[[1,[6,[7,[7,"randomGeneratorSlot","value"],"sample"],[]],"*",[5,"6"]]]]],[13,"axis",[1,"face","%",[5,"3"]]],[13,"result",[6,[7,"d","vec3f"],[]]],[2,[8,"result","axis"],"=",[6,[7,"d","f32"],[[6,"select",[[5,"0"],[5,"1"],[1,"face",">",[5,"2"]]]]]]],[2,[8,"result",[1,[1,"axis","+",[5,"1"]],"%",[5,"3"]]],"=",[6,[7,[7,"randomGeneratorSlot","value"],"sample"],[]]],[2,[8,"result",[1,[1,"axis","+",[5,"2"]],"%",[5,"3"]]],"=",[6,[7,[7,"randomGeneratorSlot","value"],"sample"],[]]],[10,"result"]]],"externalNames":["d","randomGeneratorSlot","select"]},
              externals: () => ({d, randomGeneratorSlot, select}),
            }) && $.f)({}))), "randOnUnitCube"));
const randInUnitCircle = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([], d.vec2f)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = (() => {
  const radius = sqrt(randomGeneratorSlot.value.sample());
  const angle = randomGeneratorSlot.value.sample() * TWO_PI;
  return d.vec2f(cos(angle) * radius, sin(angle) * radius);
}), {
              v: 1,
              name: undefined,
              ast: {"params":[],"body":[0,[[13,"radius",[6,"sqrt",[[6,[7,[7,"randomGeneratorSlot","value"],"sample"],[]]]]],[13,"angle",[1,[6,[7,[7,"randomGeneratorSlot","value"],"sample"],[]],"*","TWO_PI"]],[10,[6,[7,"d","vec2f"],[[1,[6,"cos",["angle"]],"*","radius"],[1,[6,"sin",["angle"]],"*","radius"]]]]]],"externalNames":["sqrt","randomGeneratorSlot","TWO_PI","d","cos","sin"]},
              externals: () => ({sqrt, randomGeneratorSlot, TWO_PI, d, cos, sin}),
            }) && $.f)({}))), "randInUnitCircle"));
const randOnUnitCircle = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([], d.vec2f)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = (() => {
  const angle = randomGeneratorSlot.value.sample() * TWO_PI;
  return d.vec2f(cos(angle), sin(angle));
}), {
              v: 1,
              name: undefined,
              ast: {"params":[],"body":[0,[[13,"angle",[1,[6,[7,[7,"randomGeneratorSlot","value"],"sample"],[]],"*","TWO_PI"]],[10,[6,[7,"d","vec2f"],[[6,"cos",["angle"]],[6,"sin",["angle"]]]]]]],"externalNames":["randomGeneratorSlot","TWO_PI","d","cos","sin"]},
              externals: () => ({randomGeneratorSlot, TWO_PI, d, cos, sin}),
            }) && $.f)({}))), "randOnUnitCircle"));
((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec3f], d.vec3f)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((v) => {
  let vNonZero = v;
  if (length(v) === 0) {
    vNonZero = v.add(EPS);
  }
  return normalize(vNonZero);
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"v"}],"body":[0,[[12,"vNonZero","v"],[11,[1,[6,"length",["v"]],"===",[5,"0"]],[0,[[2,"vNonZero","=",[6,[7,"v","add"],["EPS"]]]]]],[10,[6,"normalize",["vNonZero"]]]]],"externalNames":["length","EPS","normalize"]},
              externals: () => ({length, EPS, normalize}),
            }) && $.f)({}))), "safeNormalize"));
const randInUnitSphere = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([], d.vec3f)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = (() => {
  const u = randomGeneratorSlot.value.sample();
  const v = d.vec3f(randNormal(0, 1), randNormal(0, 1), randNormal(0, 1));
  const vNorm = normalize(v);
  return vNorm.mul(pow(u, 0.33));
}), {
              v: 1,
              name: undefined,
              ast: {"params":[],"body":[0,[[13,"u",[6,[7,[7,"randomGeneratorSlot","value"],"sample"],[]]],[13,"v",[6,[7,"d","vec3f"],[[6,"randNormal",[[5,"0"],[5,"1"]]],[6,"randNormal",[[5,"0"],[5,"1"]]],[6,"randNormal",[[5,"0"],[5,"1"]]]]]],[13,"vNorm",[6,"normalize",["v"]]],[10,[6,[7,"vNorm","mul"],[[6,"pow",["u",[5,"0.33"]]]]]]]],"externalNames":["randomGeneratorSlot","d","randNormal","normalize","pow"]},
              externals: () => ({randomGeneratorSlot, d, randNormal, normalize, pow}),
            }) && $.f)({}))), "randInUnitSphere"));
const randOnUnitSphere = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([], d.vec3f)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = (() => {
  const z = 2 * randomGeneratorSlot.value.sample() - 1;
  const oneMinusZSq = sqrt(1 - z * z);
  const theta = TWO_PI * randomGeneratorSlot.value.sample();
  const x = cos(theta) * oneMinusZSq;
  const y = sin(theta) * oneMinusZSq;
  return d.vec3f(x, y, z);
}), {
              v: 1,
              name: undefined,
              ast: {"params":[],"body":[0,[[13,"z",[1,[1,[5,"2"],"*",[6,[7,[7,"randomGeneratorSlot","value"],"sample"],[]]],"-",[5,"1"]]],[13,"oneMinusZSq",[6,"sqrt",[[1,[5,"1"],"-",[1,"z","*","z"]]]]],[13,"theta",[1,"TWO_PI","*",[6,[7,[7,"randomGeneratorSlot","value"],"sample"],[]]]],[13,"x",[1,[6,"cos",["theta"]],"*","oneMinusZSq"]],[13,"y",[1,[6,"sin",["theta"]],"*","oneMinusZSq"]],[10,[6,[7,"d","vec3f"],["x","y","z"]]]]],"externalNames":["randomGeneratorSlot","sqrt","TWO_PI","cos","sin","d"]},
              externals: () => ({randomGeneratorSlot, sqrt, TWO_PI, cos, sin, d}),
            }) && $.f)({}))), "randOnUnitSphere"));
const randInUnitHemisphere = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec3f], d.vec3f)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((normal) => {
  const value = randInUnitSphere();
  const alignment = dot(normal, value);
  return mul(sign(alignment), value);
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"normal"}],"body":[0,[[13,"value",[6,"randInUnitSphere",[]]],[13,"alignment",[6,"dot",["normal","value"]]],[10,[6,"mul",[[6,"sign",["alignment"]],"value"]]]]],"externalNames":["randInUnitSphere","dot","mul","sign"]},
              externals: () => ({randInUnitSphere, dot, mul, sign}),
            }) && $.f)({}))), "randInUnitHemisphere"));
const randOnUnitHemisphere = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec3f], d.vec3f)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((normal) => {
  const value = randOnUnitSphere();
  const alignment = dot(normal, value);
  return mul(sign(alignment), value);
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"normal"}],"body":[0,[[13,"value",[6,"randOnUnitSphere",[]]],[13,"alignment",[6,"dot",["normal","value"]]],[10,[6,"mul",[[6,"sign",["alignment"]],"value"]]]]],"externalNames":["randOnUnitSphere","dot","mul","sign"]},
              externals: () => ({randOnUnitSphere, dot, mul, sign}),
            }) && $.f)({}))), "randOnUnitHemisphere"));
const randUniformExclusive = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([], d.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = (() => {
  return randomGeneratorSlot.value.sample() * (1 - 2 * EPS) + EPS;
}), {
              v: 1,
              name: undefined,
              ast: {"params":[],"body":[0,[[10,[1,[1,[6,[7,[7,"randomGeneratorSlot","value"],"sample"],[]],"*",[1,[5,"1"],"-",[1,[5,"2"],"*","EPS"]]],"+","EPS"]]]],"externalNames":["randomGeneratorSlot","EPS"]},
              externals: () => ({randomGeneratorSlot, EPS}),
            }) && $.f)({}))), "randUniformExclusive"));
const randNormal = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.f32, d.f32], d.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((mu, sigma) => {
  const theta = TWO_PI * randUniformExclusive();
  const R = sqrt(-2 * log(randUniformExclusive()));
  return R * sin(theta) * sigma + mu;
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"mu"},{"type":"i","name":"sigma"}],"body":[0,[[13,"theta",[1,"TWO_PI","*",[6,"randUniformExclusive",[]]]],[13,"R",[6,"sqrt",[[1,[4,"-",[5,"2"]],"*",[6,"log",[[6,"randUniformExclusive",[]]]]]]]],[10,[1,[1,[1,"R","*",[6,"sin",["theta"]]],"*","sigma"],"+","mu"]]]],"externalNames":["TWO_PI","randUniformExclusive","sqrt","log","sin"]},
              externals: () => ({TWO_PI, randUniformExclusive, sqrt, log, sin}),
            }) && $.f)({}))), "randNormal"));
const randExponential = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.f32], d.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((rate) => {
  const u = randUniformExclusive();
  return -1 / rate * log(u);
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"rate"}],"body":[0,[[13,"u",[6,"randUniformExclusive",[]]],[10,[1,[1,[4,"-",[5,"1"]],"/","rate"],"*",[6,"log",["u"]]]]]],"externalNames":["randUniformExclusive","log"]},
              externals: () => ({randUniformExclusive, log}),
            }) && $.f)({}))), "randExponential"));
const randCauchy = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.f32, d.f32], d.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((x0, gamma) => {
  const u = randUniformExclusive();
  return x0 + gamma * tan(Math.PI * (u - 0.5));
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"x0"},{"type":"i","name":"gamma"}],"body":[0,[[13,"u",[6,"randUniformExclusive",[]]],[10,[1,"x0","+",[1,"gamma","*",[6,"tan",[[1,[7,"Math","PI"],"*",[1,"u","-",[5,"0.5"]]]]]]]]]],"externalNames":["randUniformExclusive","tan","Math"]},
              externals: () => ({randUniformExclusive, tan, Math}),
            }) && $.f)({}))), "randCauchy"));
const randBernoulli = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.f32], d.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((p) => {
  const u = randomGeneratorSlot.value.sample();
  return step(u, p);
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"p"}],"body":[0,[[13,"u",[6,[7,[7,"randomGeneratorSlot","value"],"sample"],[]]],[10,[6,"step",["u","p"]]]]],"externalNames":["randomGeneratorSlot","step"]},
              externals: () => ({randomGeneratorSlot, step}),
            }) && $.f)({}))), "randBernoulli"));

const quinticInterpolationImpl = (($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((t) => {
  "use gpu";
  return mul(mul(t, mul(t, t)), add(mul(t, sub(mul(t, 6), 15)), 10));
}), {
              v: 1,
              name: "quinticInterpolationImpl",
              ast: {"params":[{"type":"i","name":"t"}],"body":[0,[[10,[6,"mul",[[6,"mul",["t",[6,"mul",["t","t"]]]],[6,"add",[[6,"mul",["t",[6,"sub",[[6,"mul",["t",[5,"6"]]],[5,"15"]]]]],[5,"10"]]]]]]]],"externalNames":["mul","add","sub"]},
              externals: () => ({mul, add, sub}),
            }) && $.f)({}));
const quinticInterpolation2 = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec2f], d.vec2f)(quinticInterpolationImpl), "quinticInterpolation2"));
const quinticInterpolation3 = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec3f], d.vec3f)(quinticInterpolationImpl), "quinticInterpolation3"));
const quinticDerivativeImpl = (($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((t) => {
  "use gpu";
  return mul(mul(mul(30, t), t), add(mul(t, sub(t, 2)), 1));
}), {
              v: 1,
              name: "quinticDerivativeImpl",
              ast: {"params":[{"type":"i","name":"t"}],"body":[0,[[10,[6,"mul",[[6,"mul",[[6,"mul",[[5,"30"],"t"]],"t"]],[6,"add",[[6,"mul",["t",[6,"sub",["t",[5,"2"]]]]],[5,"1"]]]]]]]],"externalNames":["mul","add","sub"]},
              externals: () => ({mul, add, sub}),
            }) && $.f)({}));
const quinticDerivative2 = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec2f], d.vec2f)(quinticDerivativeImpl), "quinticDerivative2"));
((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec3f], d.vec3f)(quinticDerivativeImpl), "quinticDerivative3"));

const computeJunctionGradient$1 = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec2i], d.vec2f)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((pos) => {
  randSeed2(mul(1e-3, d.vec2f(pos)));
  return randOnUnitCircle();
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"pos"}],"body":[0,[[6,"randSeed2",[[6,"mul",[[5,"0.001"],[6,[7,"d","vec2f"],["pos"]]]]]],[10,[6,"randOnUnitCircle",[]]]]],"externalNames":["randSeed2","mul","d","randOnUnitCircle"]},
              externals: () => ({randSeed2, mul, d, randOnUnitCircle}),
            }) && $.f)({}))), "computeJunctionGradient"));
const getJunctionGradientSlot$1 = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.slot(computeJunctionGradient$1), "getJunctionGradientSlot"));
const sample$1 = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec2f], d.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((pos) => {
  const i = d.vec2i(floor(pos));
  const f = fract(pos);
  const u = quinticInterpolation2(f);
  const ga = getJunctionGradientSlot$1.$(i);
  const gb = getJunctionGradientSlot$1.$(add(i, d.vec2i(1, 0)));
  const gc = getJunctionGradientSlot$1.$(add(i, d.vec2i(0, 1)));
  const gd = getJunctionGradientSlot$1.$(add(i, d.vec2i(1, 1)));
  const va = dot(ga, sub(f, d.vec2f(0, 0)));
  const vb = dot(gb, sub(f, d.vec2f(1, 0)));
  const vc = dot(gc, sub(f, d.vec2f(0, 1)));
  const vd = dot(gd, sub(f, d.vec2f(1, 1)));
  const noise = va + u.x * (vb - va) + u.y * (vc - va) + u.x * u.y * (va - vb - vc + vd);
  return noise;
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"pos"}],"body":[0,[[13,"i",[6,[7,"d","vec2i"],[[6,"floor",["pos"]]]]],[13,"f",[6,"fract",["pos"]]],[13,"u",[6,"quinticInterpolation2",["f"]]],[13,"ga",[6,[7,"getJunctionGradientSlot","$"],["i"]]],[13,"gb",[6,[7,"getJunctionGradientSlot","$"],[[6,"add",["i",[6,[7,"d","vec2i"],[[5,"1"],[5,"0"]]]]]]]],[13,"gc",[6,[7,"getJunctionGradientSlot","$"],[[6,"add",["i",[6,[7,"d","vec2i"],[[5,"0"],[5,"1"]]]]]]]],[13,"gd",[6,[7,"getJunctionGradientSlot","$"],[[6,"add",["i",[6,[7,"d","vec2i"],[[5,"1"],[5,"1"]]]]]]]],[13,"va",[6,"dot",["ga",[6,"sub",["f",[6,[7,"d","vec2f"],[[5,"0"],[5,"0"]]]]]]]],[13,"vb",[6,"dot",["gb",[6,"sub",["f",[6,[7,"d","vec2f"],[[5,"1"],[5,"0"]]]]]]]],[13,"vc",[6,"dot",["gc",[6,"sub",["f",[6,[7,"d","vec2f"],[[5,"0"],[5,"1"]]]]]]]],[13,"vd",[6,"dot",["gd",[6,"sub",["f",[6,[7,"d","vec2f"],[[5,"1"],[5,"1"]]]]]]]],[13,"noise",[1,[1,[1,"va","+",[1,[7,"u","x"],"*",[1,"vb","-","va"]]],"+",[1,[7,"u","y"],"*",[1,"vc","-","va"]]],"+",[1,[1,[7,"u","x"],"*",[7,"u","y"]],"*",[1,[1,[1,"va","-","vb"],"-","vc"],"+","vd"]]]],[10,"noise"]]],"externalNames":["d","floor","fract","quinticInterpolation2","getJunctionGradientSlot","add","dot","sub"]},
              externals: () => ({d, floor, fract, quinticInterpolation2, getJunctionGradientSlot: getJunctionGradientSlot$1, add, dot, sub}),
            }) && $.f)({}))), "sample"));
const sampleWithGradient = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec2f], d.vec3f)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((pos) => {
  const i = d.vec2i(floor(pos));
  const f = fract(pos);
  const u = quinticInterpolation2(f);
  const du = quinticDerivative2(f);
  const ga = getJunctionGradientSlot$1.$(i);
  const gb = getJunctionGradientSlot$1.$(add(i, d.vec2i(1, 0)));
  const gc = getJunctionGradientSlot$1.$(add(i, d.vec2i(0, 1)));
  const gd = getJunctionGradientSlot$1.$(add(i, d.vec2i(1, 1)));
  const va = dot(ga, sub(f, d.vec2f(0, 0)));
  const vb = dot(gb, sub(f, d.vec2f(1, 0)));
  const vc = dot(gc, sub(f, d.vec2f(0, 1)));
  const vd = dot(gd, sub(f, d.vec2f(1, 1)));
  const noise = va + u.x * (vb - va) + u.y * (vc - va) + u.x * u.y * (va - vb - vc + vd);
  const grad = add(
    ga,
    add(
      add(
        add(mul(u.x, sub(gb, ga)), mul(u.y, sub(gc, ga))),
        mul(u.x, mul(u.y, add(sub(sub(ga, gb), gc), gd)))
      ),
      mul(du, sub(add(mul(u.yx, va - vb - vc + vd), d.vec2f(vb, vc)), va))
    )
  );
  return d.vec3f(noise, grad);
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"pos"}],"body":[0,[[13,"i",[6,[7,"d","vec2i"],[[6,"floor",["pos"]]]]],[13,"f",[6,"fract",["pos"]]],[13,"u",[6,"quinticInterpolation2",["f"]]],[13,"du",[6,"quinticDerivative2",["f"]]],[13,"ga",[6,[7,"getJunctionGradientSlot","$"],["i"]]],[13,"gb",[6,[7,"getJunctionGradientSlot","$"],[[6,"add",["i",[6,[7,"d","vec2i"],[[5,"1"],[5,"0"]]]]]]]],[13,"gc",[6,[7,"getJunctionGradientSlot","$"],[[6,"add",["i",[6,[7,"d","vec2i"],[[5,"0"],[5,"1"]]]]]]]],[13,"gd",[6,[7,"getJunctionGradientSlot","$"],[[6,"add",["i",[6,[7,"d","vec2i"],[[5,"1"],[5,"1"]]]]]]]],[13,"va",[6,"dot",["ga",[6,"sub",["f",[6,[7,"d","vec2f"],[[5,"0"],[5,"0"]]]]]]]],[13,"vb",[6,"dot",["gb",[6,"sub",["f",[6,[7,"d","vec2f"],[[5,"1"],[5,"0"]]]]]]]],[13,"vc",[6,"dot",["gc",[6,"sub",["f",[6,[7,"d","vec2f"],[[5,"0"],[5,"1"]]]]]]]],[13,"vd",[6,"dot",["gd",[6,"sub",["f",[6,[7,"d","vec2f"],[[5,"1"],[5,"1"]]]]]]]],[13,"noise",[1,[1,[1,"va","+",[1,[7,"u","x"],"*",[1,"vb","-","va"]]],"+",[1,[7,"u","y"],"*",[1,"vc","-","va"]]],"+",[1,[1,[7,"u","x"],"*",[7,"u","y"]],"*",[1,[1,[1,"va","-","vb"],"-","vc"],"+","vd"]]]],[13,"grad",[6,"add",["ga",[6,"add",[[6,"add",[[6,"add",[[6,"mul",[[7,"u","x"],[6,"sub",["gb","ga"]]]],[6,"mul",[[7,"u","y"],[6,"sub",["gc","ga"]]]]]],[6,"mul",[[7,"u","x"],[6,"mul",[[7,"u","y"],[6,"add",[[6,"sub",[[6,"sub",["ga","gb"]],"gc"]],"gd"]]]]]]]],[6,"mul",["du",[6,"sub",[[6,"add",[[6,"mul",[[7,"u","yx"],[1,[1,[1,"va","-","vb"],"-","vc"],"+","vd"]]],[6,[7,"d","vec2f"],["vb","vc"]]]],"va"]]]]]]]]],[10,[6,[7,"d","vec3f"],["noise","grad"]]]]],"externalNames":["d","floor","fract","quinticInterpolation2","quinticDerivative2","getJunctionGradientSlot","add","dot","sub","mul"]},
              externals: () => ({d, floor, fract, quinticInterpolation2, quinticDerivative2, getJunctionGradientSlot: getJunctionGradientSlot$1, add, dot, sub, mul}),
            }) && $.f)({}))), "sampleWithGradient"));

const MemorySchema$3 = d.arrayOf(d.vec2f);
const DefaultPerlin2DLayoutPrefix = "perlin2dCache__";
function dynamicCacheConfig$1(options) {
  const { prefix = DefaultPerlin2DLayoutPrefix } = options ?? {};
  const valuesSlot = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.slot(), "valuesSlot"));
  const cleanValuesSlot = tgpu["~unstable"].derived(() => {
    return {
      get size() {
        return valuesSlot.$[`${prefix}size`];
      },
      get memory() {
        return valuesSlot.$[`${prefix}memory`];
      }
    };
  });
  const getJunctionGradient = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec2i], d.vec2f)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((pos) => {
    const size = d.vec2i(cleanValuesSlot.value.size);
    const x = (pos.x % size.x + size.x) % size.x;
    const y = (pos.y % size.y + size.y) % size.y;
    return cleanValuesSlot.value.memory[x + y * size.x];
  }), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"pos"}],"body":[0,[[13,"size",[6,[7,"d","vec2i"],[[7,[7,"cleanValuesSlot","value"],"size"]]]],[13,"x",[1,[1,[1,[7,"pos","x"],"%",[7,"size","x"]],"+",[7,"size","x"]],"%",[7,"size","x"]]],[13,"y",[1,[1,[1,[7,"pos","y"],"%",[7,"size","y"]],"+",[7,"size","y"]],"%",[7,"size","y"]]],[10,[8,[7,[7,"cleanValuesSlot","value"],"memory"],[1,"x","+",[1,"y","*",[7,"size","x"]]]]]]],"externalNames":["d","cleanValuesSlot"]},
              externals: () => ({d, cleanValuesSlot}),
            }) && $.f)({}))), "getJunctionGradient"));
  const computeLayout = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.bindGroupLayout({
    size: { uniform: d.vec2u },
    memory: { storage: MemorySchema$3, access: "mutable" }
  }), "computeLayout"));
  const mainCompute = (($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((x, y) => {
    "use gpu";
    const size = computeLayout.$.size;
    const idx = x + y * size.x;
    computeLayout.$.memory[idx] = computeJunctionGradient$1(
      d.vec2i(x, y)
    );
  }), {
              v: 1,
              name: "mainCompute",
              ast: {"params":[{"type":"i","name":"x"},{"type":"i","name":"y"}],"body":[0,[[13,"size",[7,[7,"computeLayout","$"],"size"]],[13,"idx",[1,"x","+",[1,"y","*",[7,"size","x"]]]],[2,[8,[7,[7,"computeLayout","$"],"memory"],"idx"],"=",[6,"computeJunctionGradient",[[6,[7,"d","vec2i"],["x","y"]]]]]]],"externalNames":["computeLayout","computeJunctionGradient","d"]},
              externals: () => ({computeLayout, computeJunctionGradient: computeJunctionGradient$1, d}),
            }) && $.f)({}));
  const instance = (root, initialSize) => {
    let dirty = false;
    let size = initialSize;
    const sizeBuffer = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(root.createBuffer(d.vec2u, size).$usage("uniform"), "sizeBuffer"));
    const computePipeline = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(root["~unstable"].createGuardedComputePipeline(mainCompute), "computePipeline"));
    const createMemory = () => {
      const memory = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(root.createBuffer(d.arrayOf(d.vec2f, size.x * size.y)).$usage("storage"), "memory"));
      const computeBindGroup = root.createBindGroup(computeLayout, {
        size: sizeBuffer,
        memory
      });
      computePipeline.with(computeBindGroup).dispatchThreads(size.x, size.y);
      return memory;
    };
    let memoryBuffer = createMemory();
    return {
      get size() {
        return size;
      },
      get bindings() {
        if (dirty) {
          memoryBuffer.destroy();
          memoryBuffer = createMemory();
        }
        return {
          [`${prefix}size`]: sizeBuffer,
          [`${prefix}memory`]: memoryBuffer
        };
      },
      set size(value) {
        if (allEq(size, value)) {
          return;
        }
        size = value;
        sizeBuffer.write(size);
        dirty = true;
      },
      destroy() {
        sizeBuffer.destroy();
        memoryBuffer.destroy();
      }
    };
  };
  return {
    layout: {
      [`${prefix}size`]: { uniform: d.vec2u },
      [`${prefix}memory`]: { storage: MemorySchema$3, access: "readonly" }
    },
    valuesSlot,
    getJunctionGradient,
    instance,
    inject: (layoutValue) => (cfg) => cfg.with(getJunctionGradientSlot$1, getJunctionGradient).with(valuesSlot, layoutValue)
  };
}

const MemorySchema$2 = d.arrayOf(d.vec2f);
function staticCache$1(options) {
  const { root, size } = options;
  const memoryBuffer = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(root.createBuffer(MemorySchema$2(size.x * size.y)).$usage("storage"), "memoryBuffer"));
  const memoryReadonly = memoryBuffer.as("readonly");
  const memoryMutable = memoryBuffer.as("mutable");
  const computePipeline = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(root["~unstable"].createGuardedComputePipeline((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((x, y) => {
    "use gpu";
    const idx = x + y * size.x;
    memoryMutable.$[idx] = computeJunctionGradient$1(d.vec2i(x, y));
  }), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"x"},{"type":"i","name":"y"}],"body":[0,[[13,"idx",[1,"x","+",[1,"y","*",[7,"size","x"]]]],[2,[8,[7,"memoryMutable","$"],"idx"],"=",[6,"computeJunctionGradient",[[6,[7,"d","vec2i"],["x","y"]]]]]]],"externalNames":["size","memoryMutable","computeJunctionGradient","d"]},
              externals: () => ({size, memoryMutable, computeJunctionGradient: computeJunctionGradient$1, d}),
            }) && $.f)({}))), "computePipeline"));
  computePipeline.dispatchThreads(size.x, size.y);
  const getJunctionGradient = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec2i], d.vec2f)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((pos) => {
    const size_i = d.vec2i(size);
    const x = (pos.x % size_i.x + size_i.x) % size_i.x;
    const y = (pos.y % size_i.y + size_i.y) % size_i.y;
    return memoryReadonly.$[x + y * size_i.x];
  }), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"pos"}],"body":[0,[[13,"size_i",[6,[7,"d","vec2i"],["size"]]],[13,"x",[1,[1,[1,[7,"pos","x"],"%",[7,"size_i","x"]],"+",[7,"size_i","x"]],"%",[7,"size_i","x"]]],[13,"y",[1,[1,[1,[7,"pos","y"],"%",[7,"size_i","y"]],"+",[7,"size_i","y"]],"%",[7,"size_i","y"]]],[10,[8,[7,"memoryReadonly","$"],[1,"x","+",[1,"y","*",[7,"size_i","x"]]]]]]],"externalNames":["d","size","memoryReadonly"]},
              externals: () => ({d, size, memoryReadonly}),
            }) && $.f)({}))), "getJunctionGradient"));
  return {
    getJunctionGradient,
    get size() {
      return size;
    },
    destroy() {
      memoryBuffer.destroy();
    },
    inject: () => (cfg) => cfg.with(getJunctionGradientSlot$1, getJunctionGradient)
  };
}

const index$1 = {
  __proto__: null,
  computeJunctionGradient: computeJunctionGradient$1,
  dynamicCacheConfig: dynamicCacheConfig$1,
  getJunctionGradientSlot: getJunctionGradientSlot$1,
  sample: sample$1,
  sampleWithGradient: sampleWithGradient,
  staticCache: staticCache$1
};

const computeJunctionGradient = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec3i], d.vec3f)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((pos) => {
  randSeed3(mul(1e-3, d.vec3f(pos)));
  return randOnUnitSphere();
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"pos"}],"body":[0,[[6,"randSeed3",[[6,"mul",[[5,"0.001"],[6,[7,"d","vec3f"],["pos"]]]]]],[10,[6,"randOnUnitSphere",[]]]]],"externalNames":["randSeed3","mul","d","randOnUnitSphere"]},
              externals: () => ({randSeed3, mul, d, randOnUnitSphere}),
            }) && $.f)({}))), "computeJunctionGradient"));
const getJunctionGradientSlot = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.slot(computeJunctionGradient), "getJunctionGradientSlot"));
const dotProdGrid = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec3f, d.vec3f], d.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((pos, junction) => {
  const relative = sub(pos, junction);
  const gridVector = getJunctionGradientSlot.value(d.vec3i(junction));
  return dot(relative, gridVector);
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"pos"},{"type":"i","name":"junction"}],"body":[0,[[13,"relative",[6,"sub",["pos","junction"]]],[13,"gridVector",[6,[7,"getJunctionGradientSlot","value"],[[6,[7,"d","vec3i"],["junction"]]]]],[10,[6,"dot",["relative","gridVector"]]]]],"externalNames":["sub","getJunctionGradientSlot","d","dot"]},
              externals: () => ({sub, getJunctionGradientSlot, d, dot}),
            }) && $.f)({}))), "dotProdGrid"));
const sample = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec3f], d.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((pos) => {
  const minJunction = floor(pos);
  const xyz = dotProdGrid(pos, minJunction);
  const xyZ = dotProdGrid(pos, add(minJunction, d.vec3f(0, 0, 1)));
  const xYz = dotProdGrid(pos, add(minJunction, d.vec3f(0, 1, 0)));
  const xYZ = dotProdGrid(pos, add(minJunction, d.vec3f(0, 1, 1)));
  const Xyz = dotProdGrid(pos, add(minJunction, d.vec3f(1, 0, 0)));
  const XyZ = dotProdGrid(pos, add(minJunction, d.vec3f(1, 0, 1)));
  const XYz = dotProdGrid(pos, add(minJunction, d.vec3f(1, 1, 0)));
  const XYZ = dotProdGrid(pos, add(minJunction, d.vec3f(1, 1, 1)));
  const partial = sub(pos, minJunction);
  const smoothPartial = quinticInterpolation3(partial);
  const xy = mix(xyz, xyZ, smoothPartial.z);
  const xY = mix(xYz, xYZ, smoothPartial.z);
  const Xy = mix(Xyz, XyZ, smoothPartial.z);
  const XY = mix(XYz, XYZ, smoothPartial.z);
  const x = mix(xy, xY, smoothPartial.y);
  const X = mix(Xy, XY, smoothPartial.y);
  return mix(x, X, smoothPartial.x);
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"pos"}],"body":[0,[[13,"minJunction",[6,"floor",["pos"]]],[13,"xyz",[6,"dotProdGrid",["pos","minJunction"]]],[13,"xyZ",[6,"dotProdGrid",["pos",[6,"add",["minJunction",[6,[7,"d","vec3f"],[[5,"0"],[5,"0"],[5,"1"]]]]]]]],[13,"xYz",[6,"dotProdGrid",["pos",[6,"add",["minJunction",[6,[7,"d","vec3f"],[[5,"0"],[5,"1"],[5,"0"]]]]]]]],[13,"xYZ",[6,"dotProdGrid",["pos",[6,"add",["minJunction",[6,[7,"d","vec3f"],[[5,"0"],[5,"1"],[5,"1"]]]]]]]],[13,"Xyz",[6,"dotProdGrid",["pos",[6,"add",["minJunction",[6,[7,"d","vec3f"],[[5,"1"],[5,"0"],[5,"0"]]]]]]]],[13,"XyZ",[6,"dotProdGrid",["pos",[6,"add",["minJunction",[6,[7,"d","vec3f"],[[5,"1"],[5,"0"],[5,"1"]]]]]]]],[13,"XYz",[6,"dotProdGrid",["pos",[6,"add",["minJunction",[6,[7,"d","vec3f"],[[5,"1"],[5,"1"],[5,"0"]]]]]]]],[13,"XYZ",[6,"dotProdGrid",["pos",[6,"add",["minJunction",[6,[7,"d","vec3f"],[[5,"1"],[5,"1"],[5,"1"]]]]]]]],[13,"partial",[6,"sub",["pos","minJunction"]]],[13,"smoothPartial",[6,"quinticInterpolation3",["partial"]]],[13,"xy",[6,"mix",["xyz","xyZ",[7,"smoothPartial","z"]]]],[13,"xY",[6,"mix",["xYz","xYZ",[7,"smoothPartial","z"]]]],[13,"Xy",[6,"mix",["Xyz","XyZ",[7,"smoothPartial","z"]]]],[13,"XY",[6,"mix",["XYz","XYZ",[7,"smoothPartial","z"]]]],[13,"x",[6,"mix",["xy","xY",[7,"smoothPartial","y"]]]],[13,"X",[6,"mix",["Xy","XY",[7,"smoothPartial","y"]]]],[10,[6,"mix",["x","X",[7,"smoothPartial","x"]]]]]],"externalNames":["floor","dotProdGrid","add","d","sub","quinticInterpolation3","mix"]},
              externals: () => ({floor, dotProdGrid, add, d, sub, quinticInterpolation3, mix}),
            }) && $.f)({}))), "sample"));

const MemorySchema$1 = d.arrayOf(d.vec3f);
const DefaultPerlin3DLayoutPrefix = "perlin3dCache__";
function dynamicCacheConfig(options) {
  const { prefix = DefaultPerlin3DLayoutPrefix } = options ?? {};
  const valuesSlot = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.slot(), "valuesSlot"));
  const cleanValuesSlot = tgpu["~unstable"].derived(() => {
    return {
      get size() {
        return valuesSlot.$[`${prefix}size`];
      },
      get memory() {
        return valuesSlot.$[`${prefix}memory`];
      }
    };
  });
  const getJunctionGradient = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec3i], d.vec3f)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((pos) => {
    const size = d.vec3i(cleanValuesSlot.$.size.xyz);
    const x = (pos.x % size.x + size.x) % size.x;
    const y = (pos.y % size.y + size.y) % size.y;
    const z = (pos.z % size.z + size.z) % size.z;
    return cleanValuesSlot.$.memory[x + y * size.x + z * size.x * size.y];
  }), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"pos"}],"body":[0,[[13,"size",[6,[7,"d","vec3i"],[[7,[7,[7,"cleanValuesSlot","$"],"size"],"xyz"]]]],[13,"x",[1,[1,[1,[7,"pos","x"],"%",[7,"size","x"]],"+",[7,"size","x"]],"%",[7,"size","x"]]],[13,"y",[1,[1,[1,[7,"pos","y"],"%",[7,"size","y"]],"+",[7,"size","y"]],"%",[7,"size","y"]]],[13,"z",[1,[1,[1,[7,"pos","z"],"%",[7,"size","z"]],"+",[7,"size","z"]],"%",[7,"size","z"]]],[10,[8,[7,[7,"cleanValuesSlot","$"],"memory"],[1,[1,"x","+",[1,"y","*",[7,"size","x"]]],"+",[1,[1,"z","*",[7,"size","x"]],"*",[7,"size","y"]]]]]]],"externalNames":["d","cleanValuesSlot"]},
              externals: () => ({d, cleanValuesSlot}),
            }) && $.f)({}))), "getJunctionGradient"));
  const computeLayout = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.bindGroupLayout({
    size: { uniform: d.vec4u },
    memory: { storage: MemorySchema$1, access: "mutable" }
  }), "computeLayout"));
  const mainCompute = (($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((x, y, z) => {
    "use gpu";
    const size = computeLayout.$.size;
    const idx = x + y * size.x + z * size.x * size.y;
    computeLayout.$.memory[idx] = computeJunctionGradient(d.vec3i(x, y, z));
  }), {
              v: 1,
              name: "mainCompute",
              ast: {"params":[{"type":"i","name":"x"},{"type":"i","name":"y"},{"type":"i","name":"z"}],"body":[0,[[13,"size",[7,[7,"computeLayout","$"],"size"]],[13,"idx",[1,[1,"x","+",[1,"y","*",[7,"size","x"]]],"+",[1,[1,"z","*",[7,"size","x"]],"*",[7,"size","y"]]]],[2,[8,[7,[7,"computeLayout","$"],"memory"],"idx"],"=",[6,"computeJunctionGradient",[[6,[7,"d","vec3i"],["x","y","z"]]]]]]],"externalNames":["computeLayout","computeJunctionGradient","d"]},
              externals: () => ({computeLayout, computeJunctionGradient, d}),
            }) && $.f)({}));
  const instance = (root, initialSize) => {
    let dirty = false;
    let size = d.vec4u(initialSize, 0);
    const sizeBuffer = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(root.createBuffer(d.vec4u, size).$usage("uniform"), "sizeBuffer"));
    const computePipeline = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(root["~unstable"].createGuardedComputePipeline(mainCompute), "computePipeline"));
    const createMemory = () => {
      const memory = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(root.createBuffer(d.arrayOf(d.vec3f, size.x * size.y * size.z)).$usage("storage"), "memory"));
      const computeBindGroup = root.createBindGroup(computeLayout, {
        size: sizeBuffer,
        memory
      });
      computePipeline.with(computeBindGroup).dispatchThreads(size.x, size.y, size.z);
      return memory;
    };
    let memoryBuffer = createMemory();
    return {
      get size() {
        return size.xyz;
      },
      get bindings() {
        if (dirty) {
          memoryBuffer.destroy();
          memoryBuffer = createMemory();
        }
        return {
          [`${prefix}size`]: sizeBuffer,
          [`${prefix}memory`]: memoryBuffer
        };
      },
      set size(_value) {
        const value = d.vec4u(_value, 0);
        if (allEq(size, value)) {
          return;
        }
        size = value;
        sizeBuffer.write(size);
        dirty = true;
      },
      destroy() {
        sizeBuffer.destroy();
        memoryBuffer.destroy();
      }
    };
  };
  return {
    layout: {
      [`${prefix}size`]: { uniform: d.vec4u },
      [`${prefix}memory`]: { storage: MemorySchema$1, access: "readonly" }
    },
    valuesSlot,
    getJunctionGradient,
    instance,
    inject: (layoutValue) => (cfg) => cfg.with(getJunctionGradientSlot, getJunctionGradient).with(valuesSlot, layoutValue)
  };
}

const MemorySchema = d.arrayOf(d.vec3f);
function staticCache(options) {
  const { root, size } = options;
  const memoryBuffer = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(root.createBuffer(MemorySchema(size.x * size.y * size.z)).$usage("storage"), "memoryBuffer"));
  const memoryReadonly = memoryBuffer.as("readonly");
  const memoryMutable = memoryBuffer.as("mutable");
  const computePipeline = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(root["~unstable"].createGuardedComputePipeline((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((x, y, z) => {
    "use gpu";
    const idx = x + y * size.x + z * size.x * size.y;
    memoryMutable.$[idx] = computeJunctionGradient(d.vec3i(x, y, z));
  }), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"x"},{"type":"i","name":"y"},{"type":"i","name":"z"}],"body":[0,[[13,"idx",[1,[1,"x","+",[1,"y","*",[7,"size","x"]]],"+",[1,[1,"z","*",[7,"size","x"]],"*",[7,"size","y"]]]],[2,[8,[7,"memoryMutable","$"],"idx"],"=",[6,"computeJunctionGradient",[[6,[7,"d","vec3i"],["x","y","z"]]]]]]],"externalNames":["size","memoryMutable","computeJunctionGradient","d"]},
              externals: () => ({size, memoryMutable, computeJunctionGradient, d}),
            }) && $.f)({}))), "computePipeline"));
  computePipeline.dispatchThreads(size.x, size.y, size.z);
  const getJunctionGradient = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.fn([d.vec3i], d.vec3f)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((pos) => {
    const size_i = d.vec3i(size);
    const x = (pos.x % size_i.x + size_i.x) % size_i.x;
    const y = (pos.y % size_i.y + size_i.y) % size_i.y;
    const z = (pos.z % size_i.z + size_i.z) % size_i.z;
    return memoryReadonly.$[x + y * size_i.x + z * size_i.x * size_i.y];
  }), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"pos"}],"body":[0,[[13,"size_i",[6,[7,"d","vec3i"],["size"]]],[13,"x",[1,[1,[1,[7,"pos","x"],"%",[7,"size_i","x"]],"+",[7,"size_i","x"]],"%",[7,"size_i","x"]]],[13,"y",[1,[1,[1,[7,"pos","y"],"%",[7,"size_i","y"]],"+",[7,"size_i","y"]],"%",[7,"size_i","y"]]],[13,"z",[1,[1,[1,[7,"pos","z"],"%",[7,"size_i","z"]],"+",[7,"size_i","z"]],"%",[7,"size_i","z"]]],[10,[8,[7,"memoryReadonly","$"],[1,[1,"x","+",[1,"y","*",[7,"size_i","x"]]],"+",[1,[1,"z","*",[7,"size_i","x"]],"*",[7,"size_i","y"]]]]]]],"externalNames":["d","size","memoryReadonly"]},
              externals: () => ({d, size, memoryReadonly}),
            }) && $.f)({}))), "getJunctionGradient"));
  return {
    getJunctionGradient,
    get size() {
      return size;
    },
    destroy() {
      memoryBuffer.destroy();
    },
    inject: () => (cfg) => cfg.with(getJunctionGradientSlot, getJunctionGradient)
  };
}

const index = {
  __proto__: null,
  computeJunctionGradient: computeJunctionGradient,
  dynamicCacheConfig: dynamicCacheConfig,
  getJunctionGradientSlot: getJunctionGradientSlot,
  sample: sample,
  staticCache: staticCache
};

const randf = {
  seed: randSeed,
  seed2: randSeed2,
  seed3: randSeed3,
  seed4: randSeed4,
  sample: randFloat01,
  sampleExclusive: randUniformExclusive,
  normal: randNormal,
  exponential: randExponential,
  cauchy: randCauchy,
  bernoulli: randBernoulli,
  inUnitCircle: randInUnitCircle,
  onUnitCircle: randOnUnitCircle,
  inUnitCube: randInUnitCube,
  onUnitCube: randOnUnitCube,
  inHemisphere: randInUnitHemisphere,
  onHemisphere: randOnUnitHemisphere,
  inUnitSphere: randInUnitSphere,
  onUnitSphere: randOnUnitSphere
};

export { BPETER, DefaultGenerator, index$1 as perlin2d, index as perlin3d, randf, randomGeneratorShell, randomGeneratorSlot };
