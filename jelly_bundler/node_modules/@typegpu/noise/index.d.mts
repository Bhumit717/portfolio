import * as typegpu from 'typegpu';
import { TgpuFn, TgpuFnShell, TgpuSlot, TgpuRoot, TgpuBuffer, UniformFlag, StorageFlag, Configurable } from 'typegpu';
import * as d from 'typegpu/data';

declare const randSeed: TgpuFn<(seed: d.F32) => d.Void>;
declare const randSeed2: TgpuFn<(seed: d.Vec2f) => d.Void>;
declare const randSeed3: TgpuFn<(seed: d.Vec3f) => d.Void>;
declare const randSeed4: TgpuFn<(seed: d.Vec4f) => d.Void>;
declare const randFloat01: TgpuFn<() => d.F32>;
declare const randInUnitCube: TgpuFn<() => d.Vec3f>;
declare const randOnUnitCube: TgpuFn<() => d.Vec3f>;
declare const randInUnitCircle: TgpuFn<() => d.Vec2f>;
declare const randOnUnitCircle: TgpuFn<() => d.Vec2f>;
declare const randInUnitSphere: TgpuFn<() => d.Vec3f>;
declare const randOnUnitSphere: TgpuFn<() => d.Vec3f>;
declare const randInUnitHemisphere: TgpuFn<(normal: d.Vec3f) => d.Vec3f>;
declare const randOnUnitHemisphere: TgpuFn<(normal: d.Vec3f) => d.Vec3f>;
declare const randUniformExclusive: TgpuFn<() => d.F32>;
declare const randNormal: TgpuFn<(mu: d.F32, sigma: d.F32) => d.F32>;
declare const randExponential: TgpuFn<(rate: d.F32) => d.F32>;
declare const randCauchy: TgpuFn<(x0: d.F32, gamma: d.F32) => d.F32>;
declare const randBernoulli: TgpuFn<(p: d.F32) => d.F32>;

interface StatefulGenerator {
    seed: TgpuFn<(seed: d.F32) => d.Void>;
    seed2: TgpuFn<(seed: d.Vec2f) => d.Void>;
    seed3: TgpuFn<(seed: d.Vec3f) => d.Void>;
    seed4: TgpuFn<(seed: d.Vec4f) => d.Void>;
    sample: TgpuFn<() => d.F32>;
}
declare const randomGeneratorShell: TgpuFnShell<[], d.F32>;
/**
 * Incorporated from https://www.cg.tuwien.ac.at/research/publications/2023/PETER-2023-PSW/PETER-2023-PSW-.pdf
 * "Particle System in WebGPU" by Benedikt Peter
 */
declare const BPETER: StatefulGenerator;
declare const DefaultGenerator: StatefulGenerator;
declare const randomGeneratorSlot: TgpuSlot<StatefulGenerator>;

declare const computeJunctionGradient$1: typegpu.TgpuFn<(pos: d.Vec2i) => d.Vec2f>;
declare const getJunctionGradientSlot$1: typegpu.TgpuSlot<typegpu.TgpuFn<(pos: d.Vec2i) => d.Vec2f>>;
/**
 * Returns value of Perlin Noise at point `pos`
 */
declare const sample$1: typegpu.TgpuFn<(pos: d.Vec2f) => d.F32>;
/**
 * Returns value of Perlin Noise at point `pos` as the x coordinate, and
 * the gradient of the function at that point as yz coordinates.
 */
declare const sampleWithGradient: typegpu.TgpuFn<(pos: d.Vec2f) => d.Vec3f>;

type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};
type PrefixKeys<Prefix extends string, T> = {
    [K in keyof T as K extends string ? `${Prefix}${K}` : K]: T[K];
};

declare const MemorySchema$1: (elementCount: number) => d.WgslArray<d.Vec2f>;
type Layout$1<Prefix extends string> = Prettify<PrefixKeys<Prefix, {
    readonly size: {
        uniform: d.Vec2u;
    };
    readonly memory: {
        storage: typeof MemorySchema$1;
        access: 'readonly';
    };
}>>;
type LayoutValue$1<Prefix extends string> = Prettify<PrefixKeys<Prefix, {
    readonly size: d.v2u;
    readonly memory: d.v2f[];
}>>;
type Bindings$1<Prefix extends string> = Prettify<PrefixKeys<Prefix, {
    size: TgpuBuffer<d.Vec2u> & UniformFlag;
    memory: TgpuBuffer<d.WgslArray<d.Vec2f>> & StorageFlag;
}>>;
interface DynamicPerlin2DCacheConfig<Prefix extends string> {
    readonly layout: Layout$1<Prefix>;
    readonly valuesSlot: TgpuSlot<LayoutValue$1<Prefix>>;
    readonly getJunctionGradient: TgpuFn<(pos: d.Vec2i) => d.Vec2f>;
    instance(root: TgpuRoot, initialSize: d.v2u): DynamicPerlin2DCache<Prefix>;
    inject(layoutValue: LayoutValue$1<Prefix>): (cfg: Configurable) => Configurable;
}
interface DynamicPerlin2DCache<Prefix extends string> {
    size: d.v2u;
    readonly bindings: Bindings$1<Prefix>;
    destroy(): void;
}
declare const DefaultPerlin2DLayoutPrefix: "perlin2dCache__";
/**
 * Used to instantiate caches for perlin noise generation, which reduce the amount of redundant calculations
 * if sampling is done more than once. Their domain can be changed at runtime, which makes this cache
 * *dynamic* (as opposed to `perlin2d.staticCache`, which is simpler at the cost of rigidity).
 *
 * @param options A set of general options for instances of this cache configuration.
 *
 * --- Basic usage
 * @example
 * ```ts
 * const cacheConfig = perlin2d.dynamicCacheConfig();
 * // Contains all resources that the perlin cache needs access to
 * const dynamicLayout = tgpu.bindGroupLayout({ ...cacheConfig.layout });
 *
 * // ...
 *
 * const root = await tgpu.init();
 * // Instantiating the cache with an initial size.
 * const cache = cacheConfig.instance(root, d.vec2u(10, 10));
 *
 * const pipeline = root
 *   // Plugging the cache into the pipeline
 *   .pipe(cacheConfig.inject(dynamicLayout.$))
 *   // ...
 *   .withFragment(mainFragment)
 *   .createPipeline();
 *
 * const frame = () => {
 *   // A bind group to fulfill the resource needs of the cache
 *   const group = root.createBindGroup(dynamicLayout, { ...cache.bindings });
 *
 *   pipeline
 *     .with(group)
 *     // ...
 *     .draw(3);
 * };
 * ```
 */
declare function dynamicCacheConfig$1(options?: {
    /**
     * A string of characters that gets prepended to every
     * resource this cache operates on
     * @default 'perlin2dCache__'
     */
    prefix?: undefined;
}): DynamicPerlin2DCacheConfig<typeof DefaultPerlin2DLayoutPrefix>;
declare function dynamicCacheConfig$1<Prefix extends string>(options?: {
    /**
     * A string of characters that gets prepended to every
     * resource this cache operates on
     * @default 'perlin2dCache__'
     */
    prefix: Prefix;
}): DynamicPerlin2DCacheConfig<Prefix>;

interface StaticPerlin2DCache {
    readonly getJunctionGradient: TgpuFn<(pos: d.Vec2i) => d.Vec2f>;
    readonly size: d.v2u;
    destroy(): void;
    inject(): (cfg: Configurable) => Configurable;
}
/**
 * A statically-sized cache for perlin noise generation, which reduces the amount of redundant calculations
 * if sampling is done more than once. If you'd like to change the size of the cache at runtime, see `perlin2d.dynamicCacheConfig`.
 *
 * --- Basic usage
 * @example
 * ```ts
 * const mainFragment = tgpu.fragmentFn({ out: d.vec4f })(() => {
 *   const n = perlin2d.sample(d.vec2f(1.1, 2.2));
 *   // ...
 * });
 *
 * const cache = perlin2d.staticCache({ root, size: d.vec2u(10, 10) });
 * const pipeline = root
 *   // Plugging the cache into the pipeline
 *   .pipe(cache.inject())
 *   // ...
 *   .withFragment(mainFragment)
 *   .createPipeline();
 * ```
 *
 * --- Wrapped coordinates
 * If the noise generator samples outside of the bounds of this cache, the space is wrapped around.
 * @example
 * ```ts
 * const cache = perlin2d.staticCache({ root, size: d.vec2u(10, 10) });
 * // ...
 * const value = perlin2d.sample(d.vec2f(0.5, 0));
 * const wrappedValue = perlin2d.sample(d.vec2f(10.5, 0)); // the same as `value`!
 * ```
 */
declare function staticCache$1(options: {
    /**
     * The root to use for allocating resources.
     */
    root: TgpuRoot;
    /**
     * The size of the cache.
     */
    size: d.v2u;
}): StaticPerlin2DCache;

type index$1_DynamicPerlin2DCache<Prefix extends string> = DynamicPerlin2DCache<Prefix>;
type index$1_DynamicPerlin2DCacheConfig<Prefix extends string> = DynamicPerlin2DCacheConfig<Prefix>;
type index$1_StaticPerlin2DCache = StaticPerlin2DCache;
declare const index$1_sampleWithGradient: typeof sampleWithGradient;
declare namespace index$1 {
  export { type index$1_DynamicPerlin2DCache as DynamicPerlin2DCache, type index$1_DynamicPerlin2DCacheConfig as DynamicPerlin2DCacheConfig, type index$1_StaticPerlin2DCache as StaticPerlin2DCache, computeJunctionGradient$1 as computeJunctionGradient, dynamicCacheConfig$1 as dynamicCacheConfig, getJunctionGradientSlot$1 as getJunctionGradientSlot, sample$1 as sample, index$1_sampleWithGradient as sampleWithGradient, staticCache$1 as staticCache };
}

declare const computeJunctionGradient: typegpu.TgpuFn<(pos: d.Vec3i) => d.Vec3f>;
declare const getJunctionGradientSlot: typegpu.TgpuSlot<typegpu.TgpuFn<(pos: d.Vec3i) => d.Vec3f>>;
declare const sample: typegpu.TgpuFn<(pos: d.Vec3f) => d.F32>;

declare const MemorySchema: (elementCount: number) => d.WgslArray<d.Vec3f>;
type Layout<Prefix extends string> = Prettify<PrefixKeys<Prefix, {
    readonly size: {
        uniform: d.Vec4u;
    };
    readonly memory: {
        storage: typeof MemorySchema;
        access: 'readonly';
    };
}>>;
type LayoutValue<Prefix extends string> = Prettify<PrefixKeys<Prefix, {
    readonly size: d.v4u;
    readonly memory: d.v3f[];
}>>;
type Bindings<Prefix extends string> = Prettify<PrefixKeys<Prefix, {
    size: TgpuBuffer<d.Vec4u> & UniformFlag;
    memory: TgpuBuffer<d.WgslArray<d.Vec3f>> & StorageFlag;
}>>;
interface DynamicPerlin3DCacheConfig<Prefix extends string> {
    readonly layout: Layout<Prefix>;
    readonly valuesSlot: TgpuSlot<LayoutValue<Prefix>>;
    readonly getJunctionGradient: TgpuFn<(pos: d.Vec3i) => d.Vec3f>;
    instance(root: TgpuRoot, initialSize: d.v3u): DynamicPerlin3DCache<Prefix>;
    inject(layoutValue: LayoutValue<Prefix>): (cfg: Configurable) => Configurable;
}
interface DynamicPerlin3DCache<Prefix extends string> {
    size: d.v3u;
    readonly bindings: Bindings<Prefix>;
    destroy(): void;
}
declare const DefaultPerlin3DLayoutPrefix: "perlin3dCache__";
/**
 * Used to instantiate caches for perlin noise generation, which reduce the amount of redundant calculations
 * if sampling is done more than once. Their domain can be changed at runtime, which makes this cache
 * *dynamic* (as opposed to `perlin3d.staticCache`, which is simpler at the cost of rigidity).
 *
 * @param options A set of general options for instances of this cache configuration.
 *
 * --- Basic usage
 * @example
 * ```ts
 * const perlinCacheConfig = perlin3d.dynamicCacheConfig();
 * // Contains all resources that the perlin cache needs access to
 * const dynamicLayout = tgpu.bindGroupLayout({ ...perlinCacheConfig.layout });
 *
 * // ...
 *
 * const root = await tgpu.init();
 * // Instantiating the cache with an initial size.
 * const perlinCache = perlinCacheConfig.instance(root, d.vec3u(10, 10, 1));
 *
 * const pipeline = root
 *   // Plugging the cache into the pipeline
 *   .pipe(perlinCacheConfig.inject(dynamicLayout.$))
 *   // ...
 *   .withFragment(mainFragment)
 *   .createPipeline();
 *
 * const frame = () => {
 *   // A bind group to fulfill the resource needs of the cache
 *   const group = root.createBindGroup(dynamicLayout, { ...perlinCache.bindings });
 *
 *   pipeline
 *     .with(group)
 *     // ...
 *     .draw(3);
 * };
 * ```
 */
declare function dynamicCacheConfig(options?: {
    /**
     * A string of characters that gets prepended to every
     * resource this cache operates on
     * @default 'perlin3dCache__'
     */
    prefix?: undefined;
}): DynamicPerlin3DCacheConfig<typeof DefaultPerlin3DLayoutPrefix>;
declare function dynamicCacheConfig<Prefix extends string>(options?: {
    /**
     * A string of characters that gets prepended to every
     * resource this cache operates on
     * @default 'perlin3dCache__'
     */
    prefix: Prefix;
}): DynamicPerlin3DCacheConfig<Prefix>;

interface StaticPerlin3DCache {
    readonly getJunctionGradient: TgpuFn<(pos: d.Vec3i) => d.Vec3f>;
    readonly size: d.v3u;
    destroy(): void;
    inject(): (cfg: Configurable) => Configurable;
}
/**
 * A statically-sized cache for perlin noise generation, which reduces the amount of redundant calculations
 * if sampling is done more than once. If you'd like to change the size of the cache at runtime, see `perlin3d.dynamicCacheConfig`.
 *
 * --- Basic usage
 * @example
 * ```ts
 * const mainFragment = tgpu.fragmentFn({ out: d.vec4f })(() => {
 *   const n = perlin3d.sample(d.vec3f(1.1, 2.2, 3.3));
 *   // ...
 * });
 *
 * const cache = perlin3d.staticCache({ root, size: d.vec3u(10, 10, 1) });
 * const pipeline = root
 *   // Plugging the cache into the pipeline
 *   .pipe(cache.inject())
 *   // ...
 *   .withFragment(mainFragment)
 *   .createPipeline();
 * ```
 *
 * --- Wrapped coordinates
 *
 * If the noise generator samples outside of the bounds of this cache, the space is wrapped around.
 * @example
 * ```ts
 * const cache = perlin3d.staticCache({ root, size: d.vec3u(10, 10, 1) });
 * // ...
 * const value = perlin3d.sample(d.vec3f(0.5, 0, 0));
 * const wrappedValue = perlin3d.sample(d.vec3f(10.5, 0, 0)); // the same as `value`!
 * ```
 */
declare function staticCache(options: {
    /**
     * The root to use for allocating resources.
     */
    root: TgpuRoot;
    /**
     * The size of the cache.
     */
    size: d.v3u;
}): StaticPerlin3DCache;

type index_DynamicPerlin3DCache<Prefix extends string> = DynamicPerlin3DCache<Prefix>;
type index_DynamicPerlin3DCacheConfig<Prefix extends string> = DynamicPerlin3DCacheConfig<Prefix>;
type index_StaticPerlin3DCache = StaticPerlin3DCache;
declare const index_computeJunctionGradient: typeof computeJunctionGradient;
declare const index_dynamicCacheConfig: typeof dynamicCacheConfig;
declare const index_getJunctionGradientSlot: typeof getJunctionGradientSlot;
declare const index_sample: typeof sample;
declare const index_staticCache: typeof staticCache;
declare namespace index {
  export { type index_DynamicPerlin3DCache as DynamicPerlin3DCache, type index_DynamicPerlin3DCacheConfig as DynamicPerlin3DCacheConfig, type index_StaticPerlin3DCache as StaticPerlin3DCache, index_computeJunctionGradient as computeJunctionGradient, index_dynamicCacheConfig as dynamicCacheConfig, index_getJunctionGradientSlot as getJunctionGradientSlot, index_sample as sample, index_staticCache as staticCache };
}

declare const randf: {
    seed: typeof randSeed;
    seed2: typeof randSeed2;
    seed3: typeof randSeed3;
    seed4: typeof randSeed4;
    sample: typeof randFloat01;
    sampleExclusive: typeof randUniformExclusive;
    normal: typeof randNormal;
    exponential: typeof randExponential;
    cauchy: typeof randCauchy;
    bernoulli: typeof randBernoulli;
    inUnitCircle: typeof randInUnitCircle;
    onUnitCircle: typeof randOnUnitCircle;
    inUnitCube: typeof randInUnitCube;
    onUnitCube: typeof randOnUnitCube;
    inHemisphere: typeof randInUnitHemisphere;
    onHemisphere: typeof randOnUnitHemisphere;
    inUnitSphere: typeof randInUnitSphere;
    onUnitSphere: typeof randOnUnitSphere;
};

export { BPETER, DefaultGenerator, index$1 as perlin2d, index as perlin3d, randf, randomGeneratorShell, randomGeneratorSlot };
