'use strict';

const tgpu = require('typegpu');
const d = require('typegpu/data');
const std = require('typegpu/std');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      n[k] = e[k];
    }
  }
  n.default = e;
  return n;
}

const tgpu__default = /*#__PURE__*/_interopDefaultCompat(tgpu);
const d__namespace = /*#__PURE__*/_interopNamespaceCompat(d);
const std__namespace = /*#__PURE__*/_interopNamespaceCompat(std);

const sdDisk = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu__default.fn([d.vec2f, d.f32], d.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((point, radius) => {
  return std.length(point) - radius;
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"point"},{"type":"i","name":"radius"}],"body":[0,[[10,[1,[6,"length",["point"]],"-","radius"]]]],"externalNames":["length"]},
              externals: () => ({length: std.length}),
            }) && $.f)({}))), "sdDisk"));
const sdBox2d = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu__default.fn([d.vec2f, d.vec2f], d.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((point, size) => {
  const d$1 = std.sub(std.abs(point), size);
  return std.length(std.max(d$1, d.vec2f(0))) + std.min(std.max(d$1.x, d$1.y), 0);
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"point"},{"type":"i","name":"size"}],"body":[0,[[13,"d",[6,"sub",[[6,"abs",["point"]],"size"]]],[10,[1,[6,"length",[[6,"max",["d",[6,"vec2f",[[5,"0"]]]]]]],"+",[6,"min",[[6,"max",[[7,"d","x"],[7,"d","y"]]],[5,"0"]]]]]]],"externalNames":["sub","abs","length","max","vec2f","min"]},
              externals: () => ({sub: std.sub, abs: std.abs, length: std.length, max: std.max, vec2f: d.vec2f, min: std.min}),
            }) && $.f)({}))), "sdBox2d"));
const sdRoundedBox2d = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu__default.fn([d.vec2f, d.vec2f, d.f32], d.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((point, size, cornerRadius) => {
  const d$1 = std.add(std.sub(std.abs(point), size), d.vec2f(cornerRadius));
  return std.length(std.max(d$1, d.vec2f(0))) + std.min(std.max(d$1.x, d$1.y), 0) - cornerRadius;
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"point"},{"type":"i","name":"size"},{"type":"i","name":"cornerRadius"}],"body":[0,[[13,"d",[6,"add",[[6,"sub",[[6,"abs",["point"]],"size"]],[6,"vec2f",["cornerRadius"]]]]],[10,[1,[1,[6,"length",[[6,"max",["d",[6,"vec2f",[[5,"0"]]]]]]],"+",[6,"min",[[6,"max",[[7,"d","x"],[7,"d","y"]]],[5,"0"]]]],"-","cornerRadius"]]]],"externalNames":["add","sub","abs","vec2f","length","max","min"]},
              externals: () => ({add: std.add, sub: std.sub, abs: std.abs, vec2f: d.vec2f, length: std.length, max: std.max, min: std.min}),
            }) && $.f)({}))), "sdRoundedBox2d"));
const sdLine = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu__default.fn([d.vec2f, d.vec2f, d.vec2f], d.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((point, A, B) => {
  const pa = std.sub(point, A);
  const ba = std.sub(B, A);
  const h = std.max(0, std.min(1, std.dot(pa, ba) / std.dot(ba, ba)));
  return std.length(std.sub(pa, ba.mul(h)));
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"point"},{"type":"i","name":"A"},{"type":"i","name":"B"}],"body":[0,[[13,"pa",[6,"sub",["point","A"]]],[13,"ba",[6,"sub",["B","A"]]],[13,"h",[6,"max",[[5,"0"],[6,"min",[[5,"1"],[1,[6,"dot",["pa","ba"]],"/",[6,"dot",["ba","ba"]]]]]]]],[10,[6,"length",[[6,"sub",["pa",[6,[7,"ba","mul"],["h"]]]]]]]]],"externalNames":["sub","max","min","dot","length"]},
              externals: () => ({sub: std.sub, max: std.max, min: std.min, dot: std.dot, length: std.length}),
            }) && $.f)({}))), "sdLine"));
const dot2 = (($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((v) => {
  "use gpu";
  return std.dot(v, v);
}), {
              v: 1,
              name: "dot2",
              ast: {"params":[{"type":"i","name":"v"}],"body":[0,[[10,[6,"dot",["v","v"]]]]],"externalNames":["dot"]},
              externals: () => ({dot: std.dot}),
            }) && $.f)({}));
const sdBezier = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu__default.fn([d.vec2f, d.vec2f, d.vec2f, d.vec2f], d.f32)(
  (($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((point, A, B, C) => {
    const a = B.sub(A);
    const b = A.sub(B.mul(2)).add(C);
    const c = a.mul(d.f32(2));
    const d$1 = A.sub(point);
    const dotB = std.max(std.dot(b, b), 1e-4);
    const kk = 1 / dotB;
    const kx = kk * std.dot(a, b);
    const ky = kk * (d.f32(2) * std.dot(a, a) + std.dot(d$1, b)) / 3;
    const kz = kk * std.dot(d$1, a);
    let res = d.f32(0);
    const p = ky - kx * kx;
    const p3 = p * p * p;
    const q = kx * (2 * kx * kx - 3 * ky) + kz;
    let h = q * q + 4 * p3;
    if (h >= 0) {
      h = std.sqrt(h);
      const x = d.vec2f(h, -h).sub(q).mul(0.5);
      const uv = std.sign(x).mul(std.pow(std.abs(x), d.vec2f(1 / 3)));
      const t = std.clamp(uv.x + uv.y - kx, 0, 1);
      res = dot2(d$1.add(c.add(b.mul(t)).mul(t)));
    } else {
      const z = std.sqrt(-p);
      const v = std.acos(q / (p * z * 2)) / 3;
      const m = std.cos(v);
      const n = std.mul(std.sin(v), 1.732050808);
      const t = std.saturate(
        d.vec3f(m + m, -n - m, n - m).mul(z).sub(kx)
      );
      res = std.min(
        dot2(d$1.add(c.add(b.mul(t.x)).mul(t.x))),
        dot2(d$1.add(c.add(b.mul(t.y)).mul(t.y)))
      );
    }
    return std.sqrt(res);
  }), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"point"},{"type":"i","name":"A"},{"type":"i","name":"B"},{"type":"i","name":"C"}],"body":[0,[[13,"a",[6,[7,"B","sub"],["A"]]],[13,"b",[6,[7,[6,[7,"A","sub"],[[6,[7,"B","mul"],[[5,"2"]]]]],"add"],["C"]]],[13,"c",[6,[7,"a","mul"],[[6,"f32",[[5,"2"]]]]]],[13,"d",[6,[7,"A","sub"],["point"]]],[13,"dotB",[6,"max",[[6,"dot",["b","b"]],[5,"0.0001"]]]],[13,"kk",[1,[5,"1"],"/","dotB"]],[13,"kx",[1,"kk","*",[6,"dot",["a","b"]]]],[13,"ky",[1,[1,"kk","*",[1,[1,[6,"f32",[[5,"2"]]],"*",[6,"dot",["a","a"]]],"+",[6,"dot",["d","b"]]]],"/",[5,"3"]]],[13,"kz",[1,"kk","*",[6,"dot",["d","a"]]]],[12,"res",[6,"f32",[[5,"0"]]]],[13,"p",[1,"ky","-",[1,"kx","*","kx"]]],[13,"p3",[1,[1,"p","*","p"],"*","p"]],[13,"q",[1,[1,"kx","*",[1,[1,[1,[5,"2"],"*","kx"],"*","kx"],"-",[1,[5,"3"],"*","ky"]]],"+","kz"]],[12,"h",[1,[1,"q","*","q"],"+",[1,[5,"4"],"*","p3"]]],[11,[1,"h",">=",[5,"0"]],[0,[[2,"h","=",[6,"sqrt",["h"]]],[13,"x",[6,[7,[6,[7,[6,"vec2f",["h",[4,"-","h"]]],"sub"],["q"]],"mul"],[[5,"0.5"]]]],[13,"uv",[6,[7,[6,"sign",["x"]],"mul"],[[6,"pow",[[6,"abs",["x"]],[6,"vec2f",[[1,[5,"1"],"/",[5,"3"]]]]]]]]],[13,"t",[6,"clamp",[[1,[1,[7,"uv","x"],"+",[7,"uv","y"]],"-","kx"],[5,"0"],[5,"1"]]]],[2,"res","=",[6,"dot2",[[6,[7,"d","add"],[[6,[7,[6,[7,"c","add"],[[6,[7,"b","mul"],["t"]]]],"mul"],["t"]]]]]]]]],[0,[[13,"z",[6,"sqrt",[[4,"-","p"]]]],[13,"v",[1,[6,"acos",[[1,"q","/",[1,[1,"p","*","z"],"*",[5,"2"]]]]],"/",[5,"3"]]],[13,"m",[6,"cos",["v"]]],[13,"n",[6,"mul",[[6,"sin",["v"]],[5,"1.732050808"]]]],[13,"t",[6,"saturate",[[6,[7,[6,[7,[6,"vec3f",[[1,"m","+","m"],[1,[4,"-","n"],"-","m"],[1,"n","-","m"]]],"mul"],["z"]],"sub"],["kx"]]]]],[2,"res","=",[6,"min",[[6,"dot2",[[6,[7,"d","add"],[[6,[7,[6,[7,"c","add"],[[6,[7,"b","mul"],[[7,"t","x"]]]]],"mul"],[[7,"t","x"]]]]]]],[6,"dot2",[[6,[7,"d","add"],[[6,[7,[6,[7,"c","add"],[[6,[7,"b","mul"],[[7,"t","y"]]]]],"mul"],[[7,"t","y"]]]]]]]]]]]]],[10,[6,"sqrt",["res"]]]]],"externalNames":["f32","max","dot","sqrt","vec2f","sign","pow","abs","clamp","dot2","acos","cos","mul","sin","saturate","vec3f","min"]},
              externals: () => ({f32: d.f32, max: std.max, dot: std.dot, sqrt: std.sqrt, vec2f: d.vec2f, sign: std.sign, pow: std.pow, abs: std.abs, clamp: std.clamp, dot2, acos: std.acos, cos: std.cos, mul: std.mul, sin: std.sin, saturate: std.saturate, vec3f: d.vec3f, min: std.min}),
            }) && $.f)({}))
), "sdBezier"));
const cross = (($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((a, b) => {
  "use gpu";
  return a.x * b.y - a.y * b.x;
}), {
              v: 1,
              name: "cross",
              ast: {"params":[{"type":"i","name":"a"},{"type":"i","name":"b"}],"body":[0,[[10,[1,[1,[7,"a","x"],"*",[7,"b","y"]],"-",[1,[7,"a","y"],"*",[7,"b","x"]]]]]],"externalNames":[]},
              externals: () => ({}),
            }) && $.f)({}));
const sdBezierApprox = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu__default.fn(
  [d.vec2f, d.vec2f, d.vec2f, d.vec2f],
  d.f32
)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((point, A, B, C) => {
  const i = A.sub(C);
  const j = C.sub(B);
  const k = B.sub(A);
  const w = j.sub(k);
  const v0 = A.sub(point);
  const v1 = B.sub(point);
  const v2 = C.sub(point);
  const x = cross(v0, v2);
  const y = cross(v1, v0);
  const z = cross(v2, v1);
  const s = j.mul(y).add(k.mul(z)).mul(2).sub(i.mul(x));
  const r = (y * z - x * x * 0.25) / dot2(s);
  const t = std.saturate((0.5 * x + y + r * std.dot(s, w)) / (x + y + z));
  const d = v0.add(k.add(k).add(w.mul(t)).mul(t));
  return std.length(d);
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"point"},{"type":"i","name":"A"},{"type":"i","name":"B"},{"type":"i","name":"C"}],"body":[0,[[13,"i",[6,[7,"A","sub"],["C"]]],[13,"j",[6,[7,"C","sub"],["B"]]],[13,"k",[6,[7,"B","sub"],["A"]]],[13,"w",[6,[7,"j","sub"],["k"]]],[13,"v0",[6,[7,"A","sub"],["point"]]],[13,"v1",[6,[7,"B","sub"],["point"]]],[13,"v2",[6,[7,"C","sub"],["point"]]],[13,"x",[6,"cross",["v0","v2"]]],[13,"y",[6,"cross",["v1","v0"]]],[13,"z",[6,"cross",["v2","v1"]]],[13,"s",[6,[7,[6,[7,[6,[7,[6,[7,"j","mul"],["y"]],"add"],[[6,[7,"k","mul"],["z"]]]],"mul"],[[5,"2"]]],"sub"],[[6,[7,"i","mul"],["x"]]]]],[13,"r",[1,[1,[1,"y","*","z"],"-",[1,[1,"x","*","x"],"*",[5,"0.25"]]],"/",[6,"dot2",["s"]]]],[13,"t",[6,"saturate",[[1,[1,[1,[1,[5,"0.5"],"*","x"],"+","y"],"+",[1,"r","*",[6,"dot",["s","w"]]]],"/",[1,[1,"x","+","y"],"+","z"]]]]],[13,"d",[6,[7,"v0","add"],[[6,[7,[6,[7,[6,[7,"k","add"],["k"]],"add"],[[6,[7,"w","mul"],["t"]]]],"mul"],["t"]]]]],[10,[6,"length",["d"]]]]],"externalNames":["cross","dot2","saturate","dot","length"]},
              externals: () => ({cross, dot2, saturate: std.saturate, dot: std.dot, length: std.length}),
            }) && $.f)({}))), "sdBezierApprox"));
const sdPie = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu__default.fn([d.vec2f, d.vec2f, d.f32], d.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((point, sc, radius) => {
  const p_w = d.vec2f(point);
  p_w.x = std.abs(point.x);
  const l = std.length(p_w) - radius;
  const m = std.length(p_w.sub(sc.mul(std.clamp(std.dot(p_w, sc), 0, radius))));
  return std.max(l, m * std.sign(sc.y * p_w.x - sc.x * p_w.y));
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"point"},{"type":"i","name":"sc"},{"type":"i","name":"radius"}],"body":[0,[[13,"p_w",[6,"vec2f",["point"]]],[2,[7,"p_w","x"],"=",[6,"abs",[[7,"point","x"]]]],[13,"l",[1,[6,"length",["p_w"]],"-","radius"]],[13,"m",[6,"length",[[6,[7,"p_w","sub"],[[6,[7,"sc","mul"],[[6,"clamp",[[6,"dot",["p_w","sc"]],[5,"0"],"radius"]]]]]]]]],[10,[6,"max",["l",[1,"m","*",[6,"sign",[[1,[1,[7,"sc","y"],"*",[7,"p_w","x"]],"-",[1,[7,"sc","x"],"*",[7,"p_w","y"]]]]]]]]]]],"externalNames":["vec2f","abs","length","clamp","dot","max","sign"]},
              externals: () => ({vec2f: d.vec2f, abs: std.abs, length: std.length, clamp: std.clamp, dot: std.dot, max: std.max, sign: std.sign}),
            }) && $.f)({}))), "sdPie"));

const sdSphere = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu__default.fn([d.vec3f, d.f32], d.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((point, radius) => {
  return std.length(point) - radius;
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"point"},{"type":"i","name":"radius"}],"body":[0,[[10,[1,[6,"length",["point"]],"-","radius"]]]],"externalNames":["length"]},
              externals: () => ({length: std.length}),
            }) && $.f)({}))), "sdSphere"));
const sdBox3d = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu__default.fn([d.vec3f, d.vec3f], d.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((point, size) => {
  const d$1 = std.sub(std.abs(point), size);
  return std.length(std.max(d$1, d.vec3f(0))) + std.min(std.max(std.max(d$1.x, d$1.y), d$1.z), 0);
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"point"},{"type":"i","name":"size"}],"body":[0,[[13,"d",[6,"sub",[[6,"abs",["point"]],"size"]]],[10,[1,[6,"length",[[6,"max",["d",[6,"vec3f",[[5,"0"]]]]]]],"+",[6,"min",[[6,"max",[[6,"max",[[7,"d","x"],[7,"d","y"]]],[7,"d","z"]]],[5,"0"]]]]]]],"externalNames":["sub","abs","length","max","vec3f","min"]},
              externals: () => ({sub: std.sub, abs: std.abs, length: std.length, max: std.max, vec3f: d.vec3f, min: std.min}),
            }) && $.f)({}))), "sdBox3d"));
const sdRoundedBox3d = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu__default.fn([d.vec3f, d.vec3f, d.f32], d.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((point, size, cornerRadius) => {
  const d$1 = std.add(std.sub(std.abs(point), size), d.vec3f(cornerRadius));
  return std.length(std.max(d$1, d.vec3f(0))) + std.min(std.max(std.max(d$1.x, d$1.y), d$1.z), 0) - cornerRadius;
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"point"},{"type":"i","name":"size"},{"type":"i","name":"cornerRadius"}],"body":[0,[[13,"d",[6,"add",[[6,"sub",[[6,"abs",["point"]],"size"]],[6,"vec3f",["cornerRadius"]]]]],[10,[1,[1,[6,"length",[[6,"max",["d",[6,"vec3f",[[5,"0"]]]]]]],"+",[6,"min",[[6,"max",[[6,"max",[[7,"d","x"],[7,"d","y"]]],[7,"d","z"]]],[5,"0"]]]],"-","cornerRadius"]]]],"externalNames":["add","sub","abs","vec3f","length","max","min"]},
              externals: () => ({add: std.add, sub: std.sub, abs: std.abs, vec3f: d.vec3f, length: std.length, max: std.max, min: std.min}),
            }) && $.f)({}))), "sdRoundedBox3d"));
const sdBoxFrame3d = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu__default.fn([d.vec3f, d.vec3f, d.f32], d.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((point, size, thickness) => {
  const p1 = std.sub(std.abs(point), size);
  const q = std.sub(std.abs(std.add(p1, thickness)), d.vec3f(thickness));
  const d1 = std.length(std.max(d.vec3f(p1.x, q.y, q.z), d.vec3f(0))) + std.min(std.max(p1.x, std.max(q.y, q.z)), 0);
  const d2 = std.length(std.max(d.vec3f(q.x, p1.y, q.z), d.vec3f(0))) + std.min(std.max(q.x, std.max(p1.y, q.z)), 0);
  const d3 = std.length(std.max(d.vec3f(q.x, q.y, p1.z), d.vec3f(0))) + std.min(std.max(q.x, std.max(q.y, p1.z)), 0);
  return std.min(std.min(d1, d2), d3);
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"point"},{"type":"i","name":"size"},{"type":"i","name":"thickness"}],"body":[0,[[13,"p1",[6,"sub",[[6,"abs",["point"]],"size"]]],[13,"q",[6,"sub",[[6,"abs",[[6,"add",["p1","thickness"]]]],[6,"vec3f",["thickness"]]]]],[13,"d1",[1,[6,"length",[[6,"max",[[6,"vec3f",[[7,"p1","x"],[7,"q","y"],[7,"q","z"]]],[6,"vec3f",[[5,"0"]]]]]]],"+",[6,"min",[[6,"max",[[7,"p1","x"],[6,"max",[[7,"q","y"],[7,"q","z"]]]]],[5,"0"]]]]],[13,"d2",[1,[6,"length",[[6,"max",[[6,"vec3f",[[7,"q","x"],[7,"p1","y"],[7,"q","z"]]],[6,"vec3f",[[5,"0"]]]]]]],"+",[6,"min",[[6,"max",[[7,"q","x"],[6,"max",[[7,"p1","y"],[7,"q","z"]]]]],[5,"0"]]]]],[13,"d3",[1,[6,"length",[[6,"max",[[6,"vec3f",[[7,"q","x"],[7,"q","y"],[7,"p1","z"]]],[6,"vec3f",[[5,"0"]]]]]]],"+",[6,"min",[[6,"max",[[7,"q","x"],[6,"max",[[7,"q","y"],[7,"p1","z"]]]]],[5,"0"]]]]],[10,[6,"min",[[6,"min",["d1","d2"]],"d3"]]]]],"externalNames":["sub","abs","add","vec3f","length","max","min"]},
              externals: () => ({sub: std.sub, abs: std.abs, add: std.add, vec3f: d.vec3f, length: std.length, max: std.max, min: std.min}),
            }) && $.f)({}))), "sdBoxFrame3d"));
const sdLine3d = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu__default.fn([d.vec3f, d.vec3f, d.vec3f], d.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((point, A, B) => {
  const pa = std.sub(point, A);
  const ba = std.sub(B, A);
  const h = std.max(0, std.min(1, std.dot(pa, ba) / std.dot(ba, ba)));
  return std.length(std.sub(pa, ba.mul(h)));
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"point"},{"type":"i","name":"A"},{"type":"i","name":"B"}],"body":[0,[[13,"pa",[6,"sub",["point","A"]]],[13,"ba",[6,"sub",["B","A"]]],[13,"h",[6,"max",[[5,"0"],[6,"min",[[5,"1"],[1,[6,"dot",["pa","ba"]],"/",[6,"dot",["ba","ba"]]]]]]]],[10,[6,"length",[[6,"sub",["pa",[6,[7,"ba","mul"],["h"]]]]]]]]],"externalNames":["sub","max","min","dot","length"]},
              externals: () => ({sub: std.sub, max: std.max, min: std.min, dot: std.dot, length: std.length}),
            }) && $.f)({}))), "sdLine3d"));
const sdPlane = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu__default.fn([d.vec3f, d.vec3f, d.f32], d.f32)(
  (($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((point, normal, height) => {
    return std.dot(point, normal) + height;
  }), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"point"},{"type":"i","name":"normal"},{"type":"i","name":"height"}],"body":[0,[[10,[1,[6,"dot",["point","normal"]],"+","height"]]]],"externalNames":["dot"]},
              externals: () => ({dot: std.dot}),
            }) && $.f)({}))
), "sdPlane"));
const sdCapsule = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu__default.fn([d.vec3f, d.vec3f, d.vec3f, d.f32], d.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((point, A, B, radius) => {
  const pa = std.sub(point, A);
  const ba = std.sub(B, A);
  const h = std.saturate(std.dot(pa, ba) / std.dot(ba, ba));
  return std.length(std.sub(pa, ba.mul(h))) - radius;
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"point"},{"type":"i","name":"A"},{"type":"i","name":"B"},{"type":"i","name":"radius"}],"body":[0,[[13,"pa",[6,"sub",["point","A"]]],[13,"ba",[6,"sub",["B","A"]]],[13,"h",[6,"saturate",[[1,[6,"dot",["pa","ba"]],"/",[6,"dot",["ba","ba"]]]]]],[10,[1,[6,"length",[[6,"sub",["pa",[6,[7,"ba","mul"],["h"]]]]]],"-","radius"]]]],"externalNames":["sub","saturate","dot","length"]},
              externals: () => ({sub: std.sub, saturate: std.saturate, dot: std.dot, length: std.length}),
            }) && $.f)({}))), "sdCapsule"));

const opUnion = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu__default.fn([d__namespace.f32, d__namespace.f32], d__namespace.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((d1, d2) => std__namespace.min(d1, d2)), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"d1"},{"type":"i","name":"d2"}],"body":[0,[[10,[6,[7,"std","min"],["d1","d2"]]]]],"externalNames":["std"]},
              externals: () => ({std: std__namespace}),
            }) && $.f)({}))), "opUnion"));
const opSmoothUnion = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu__default.fn([d__namespace.f32, d__namespace.f32, d__namespace.f32], d__namespace.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((d1, d2, k) => {
  const h = std__namespace.max(k - std__namespace.abs(d1 - d2), 0) / k;
  return std__namespace.min(d1, d2) - h * h * k * (1 / 4);
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"d1"},{"type":"i","name":"d2"},{"type":"i","name":"k"}],"body":[0,[[13,"h",[1,[6,[7,"std","max"],[[1,"k","-",[6,[7,"std","abs"],[[1,"d1","-","d2"]]]],[5,"0"]]],"/","k"]],[10,[1,[6,[7,"std","min"],["d1","d2"]],"-",[1,[1,[1,"h","*","h"],"*","k"],"*",[1,[5,"1"],"/",[5,"4"]]]]]]],"externalNames":["std"]},
              externals: () => ({std: std__namespace}),
            }) && $.f)({}))), "opSmoothUnion"));
const opSmoothDifference = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu__default.fn([d__namespace.f32, d__namespace.f32, d__namespace.f32], d__namespace.f32)((($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((d1, d2, k) => {
  const h = std__namespace.max(k - std__namespace.abs(d1 + d2), 0) / k;
  return std__namespace.max(-d2, d1) + h * h * k * (1 / 4);
}), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"d1"},{"type":"i","name":"d2"},{"type":"i","name":"k"}],"body":[0,[[13,"h",[1,[6,[7,"std","max"],[[1,"k","-",[6,[7,"std","abs"],[[1,"d1","+","d2"]]]],[5,"0"]]],"/","k"]],[10,[1,[6,[7,"std","max"],[[4,"-","d2"],"d1"]],"+",[1,[1,[1,"h","*","h"],"*","k"],"*",[1,[5,"1"],"/",[5,"4"]]]]]]],"externalNames":["std"]},
              externals: () => ({std: std__namespace}),
            }) && $.f)({}))), "opSmoothDifference"));
const opExtrudeZ = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu__default.fn([d__namespace.vec3f, d__namespace.f32, d__namespace.f32], d__namespace.f32)(
  (($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((point, dd, halfHeight) => {
    const w = d__namespace.vec2f(dd, std__namespace.abs(point.z) - halfHeight);
    return std__namespace.min(std__namespace.max(w.x, w.y), 0) + std__namespace.length(std__namespace.max(w, d__namespace.vec2f()));
  }), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"point"},{"type":"i","name":"dd"},{"type":"i","name":"halfHeight"}],"body":[0,[[13,"w",[6,[7,"d","vec2f"],["dd",[1,[6,[7,"std","abs"],[[7,"point","z"]]],"-","halfHeight"]]]],[10,[1,[6,[7,"std","min"],[[6,[7,"std","max"],[[7,"w","x"],[7,"w","y"]]],[5,"0"]]],"+",[6,[7,"std","length"],[[6,[7,"std","max"],["w",[6,[7,"d","vec2f"],[]]]]]]]]]],"externalNames":["d","std"]},
              externals: () => ({d: d__namespace, std: std__namespace}),
            }) && $.f)({}))
), "opExtrudeZ"));
const opExtrudeX = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu__default.fn([d__namespace.vec3f, d__namespace.f32, d__namespace.f32], d__namespace.f32)(
  (($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((point, dd, halfHeight) => {
    const w = d__namespace.vec2f(dd, std__namespace.abs(point.x) - halfHeight);
    return std__namespace.min(std__namespace.max(w.x, w.y), 0) + std__namespace.length(std__namespace.max(w, d__namespace.vec2f()));
  }), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"point"},{"type":"i","name":"dd"},{"type":"i","name":"halfHeight"}],"body":[0,[[13,"w",[6,[7,"d","vec2f"],["dd",[1,[6,[7,"std","abs"],[[7,"point","x"]]],"-","halfHeight"]]]],[10,[1,[6,[7,"std","min"],[[6,[7,"std","max"],[[7,"w","x"],[7,"w","y"]]],[5,"0"]]],"+",[6,[7,"std","length"],[[6,[7,"std","max"],["w",[6,[7,"d","vec2f"],[]]]]]]]]]],"externalNames":["d","std"]},
              externals: () => ({d: d__namespace, std: std__namespace}),
            }) && $.f)({}))
), "opExtrudeX"));
const opExtrudeY = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu__default.fn([d__namespace.vec3f, d__namespace.f32, d__namespace.f32], d__namespace.f32)(
  (($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = ((point, dd, halfHeight) => {
    const w = d__namespace.vec2f(dd, std__namespace.abs(point.y) - halfHeight);
    return std__namespace.min(std__namespace.max(w.x, w.y), 0) + std__namespace.length(std__namespace.max(w, d__namespace.vec2f()));
  }), {
              v: 1,
              name: undefined,
              ast: {"params":[{"type":"i","name":"point"},{"type":"i","name":"dd"},{"type":"i","name":"halfHeight"}],"body":[0,[[13,"w",[6,[7,"d","vec2f"],["dd",[1,[6,[7,"std","abs"],[[7,"point","y"]]],"-","halfHeight"]]]],[10,[1,[6,[7,"std","min"],[[6,[7,"std","max"],[[7,"w","x"],[7,"w","y"]]],[5,"0"]]],"+",[6,[7,"std","length"],[[6,[7,"std","max"],["w",[6,[7,"d","vec2f"],[]]]]]]]]]],"externalNames":["d","std"]},
              externals: () => ({d: d__namespace, std: std__namespace}),
            }) && $.f)({}))
), "opExtrudeY"));

exports.opExtrudeX = opExtrudeX;
exports.opExtrudeY = opExtrudeY;
exports.opExtrudeZ = opExtrudeZ;
exports.opSmoothDifference = opSmoothDifference;
exports.opSmoothUnion = opSmoothUnion;
exports.opUnion = opUnion;
exports.sdBezier = sdBezier;
exports.sdBezierApprox = sdBezierApprox;
exports.sdBox2d = sdBox2d;
exports.sdBox3d = sdBox3d;
exports.sdBoxFrame3d = sdBoxFrame3d;
exports.sdCapsule = sdCapsule;
exports.sdDisk = sdDisk;
exports.sdLine = sdLine;
exports.sdLine3d = sdLine3d;
exports.sdPie = sdPie;
exports.sdPlane = sdPlane;
exports.sdRoundedBox2d = sdRoundedBox2d;
exports.sdRoundedBox3d = sdRoundedBox3d;
exports.sdSphere = sdSphere;
